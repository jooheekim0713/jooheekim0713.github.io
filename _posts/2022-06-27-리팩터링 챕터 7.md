---
title: "[리팩터링] capter 7 캡슐화"
date: 2022-06-27 09:28:00 +/0900
categories: [리팩터링]
tags: [리팩터링, refactoring]    
---
	
>p.235
> 대표적인 형태인 데이터 구조는 레코드 캡슐화하기 와 컬렉션 캡슐화 하기로 캡슐화 해서 숨길 수 있다. 심지어 기본형 데이터도 기본형을 객체로 바꾸기로 캡슐화할 수 있다.
> 리팩터링할 때 임시 변수가 자주 걸리적거리는데, 정확한 순서로 계산해야하고 리팩터링 후에도 그 값을 사용하는 코드에서 접근할 수 있어야 하기 때문이다. 이럴 때는 임시변수를 질의 함수로 바꾸기가 도움된다. 특히 길이가 너무 긴 함수를 쪼개는 데 유용하다.
> 클래스는 본래 정보를 숨기는 용도로 설계되었다. 앞장에서는 여러 함수를 클래스로 묶기로 클래스를 만드는 방법을 소개했다. 이외에도 흔히 사용하는 추출하기/인라인하기 리팩터링의 클래스 버전인 클래스 추출하기와 클래스 인라인하기도 활용할 수 있다.
> 클래스는 내부 정보뿐 아니라 클래스 사이의 연결관계를 숨기는 데도 유용하다. 이 용도로는 위임숨기기가 있다. 하지만 숨기려다보면 인터페이스가 비대해질 수 있으니 반대기법인 중개자 제거하기도 필요하다. 
> 가장 큰 캡술화 단위는 클래스와 모듈이지만 함수의 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야할 때가 있는데, 함수 추출하기로 알고리즘 전체를 함수 하나에 담은 뒤 알고리즘 교체하기를 적용하면 된다.
(줄이기)

>p.236
>레코드 캡슐화하기 
>컬렉션 캡슐화하기 
>기본형을 객체로 바꾸기 
>임시변수를 질의 함수로 바꾸기  



>p.260
>클래스 추출하기
>클래스는 반드시 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다. 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다. 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다. 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다. 특정 데이터나 메서드 일부를 제거해도 논리적으로 문제가 없다면 분리할 수 있다는 뜻이다. 

## 기존의 코드
### Person class
```javascript
class Person{
	get name(){return this._name;}
	set name(arg){this._name = arg;}
	get telephoneNumber(){return `(${this.officeAreaCode})${this.officeNumber}`;}
	get officeAreaCode(){return this._officeAreaCode;}
	set officeAreaCode(arg){this._officeAreaCode = arg;}
	get officeNumber(){return this._officeNumber;}
	set officeNumber(arg){this._officeNumber = arg;}
}
```

## 수정된 코드
### Person class
```javascript
class Person{
	constructor(){
		this._telephoneNumber = new TelephoneNumber();
	}
	get name(){return this._name;}
	set name(arg){this._name = arg;}
	get telephoneNumber(){return this._telephoneNumber.toString();}
	get officeAreaCode(){return this._telephoneNumber.areaCode;}
	set officeAreaCode(arg){this._telephoneNumber.areaCode = arg;}
	get officeNumber(){return this._telephoneNumber.number;}
	set officeNumber(arg){this._telephoneNumber.number = arg;}
}
```
### TelephoneNumber class
```javascript
class TelephoneNumber{
	get toString(){return `(${this.areaCode})${this.number}`;}
	get areaCode(){return this._areaCode;}
	set areaCode(arg){this._areaCode = arg;}
	get number(){return this._number;}
	set number(arg){this._number = arg;}
}
```
> 전화번호 정보가 쓸모가 많으니 TelephoneNumber 클래스를 클라이언트에게 공개하려면 'office'로 시작하는 메서드를 없애고 TelephoneNumber의 접근자를 바로 사용하도록 바꿀 수 있다. 그러나 기왕 이렇게 쓸거라면 전화번호를 값 객체로 만드는 방법도 있다. (9.4절참조를 값으로 바꾸기 참고)


>p.264
>클래스 인라인하기
>제 역할을 못해서 그대로 두면 안되는 클래스를 인라인한다. 연락을 옮기는 리팩터링을 하고나니 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생긴다. 이럴 땐 가장 많이 사용하는 클래스로 흡수시키자.
>두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인한다. 클레스를 인라인해서 하나로 합친 다음 새로운 클래스를 추출하는 게 쉬울 수도 있기 때문이다. 

## 기존 코드
### Shipment class
```javascript
class Shipment{
	...
	get trackingInfo(){return this._trackingInformation.display;}
	get trackingInformation(){return this._trackingInformation;}
	set trackingInformation(aTrackingInformation){
		this._trackingInformation = aTrackingInformation;
	}
}
```
### TrackingInformation class
```javascript
class TrackingInformation{
	get shippingCompany(){return this._shippingCompany;}
	set shippingCompany(arg){this._shippingCompany = arg;}
	get trackingNumber(){return this._trackingNumber;}
	set trackingNumber(arg){this._trackingNumber = arg;}
	get display(){return `${this.shippingCompany} : ${this.trackingNumber}`;}
}
```
### 클라이언트
```javascript
	aShipment.trackingInformation.shippingCompany = request.vendor;
```



## 수정된 코드
### Shipment class
```javascript
class Shipment{
	...
	get shippingCompany(){return this._shippingCompany;}
	set shippingCompany(arg){this.shippingCompany = arg;}
	get trackingInfo(){return `${this.shippingCompany} : ${this.trackingNumber}`;}
	get trackingInformation(){return this._trackingInformation;}
	set trackingInformation(aTrackingInformation){
		this._trackingInformation = aTrackingInformation;
	}
	get trackingNumber(){return this._trackingNumber;}
	set trackingNumber(arg){this._trackingNumber = arg;}	
}
```

### ~~TrackingInformation class~~


### 클라이언트
```javascript
	aShipment.shippingCompany = request.vendor;
```

>p.268
>위임 숨기기
>캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야할 내용을 줄여준다. 캡슐화가 잘 되어 있다면 무언가를 변경해야 할때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기가 훨씬 쉬워진다.
>위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야한다. 이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다. 그러면 위임 객체가 수정되더라도 서버 코드만 고치면 되며, 클라이언트는 아무런 영향을 받지 않는다.


## 기존 코드
### Person class
```javascript
class Person{
	constructor(name){this._name = name;}
	get name(){return this._name;}
	get department(){return this._department;}
	set department(arg){this._department = arg;}
}
```

### Department class
```javascript
class Department{
	...
	get chargeCode(){return this._chargeCode;}
	set chargeCode(arg){this._charCode = arg;}
	get manager(){return this._manager;}
	set manager(arg){this._manager = arg;}
}
```
### 클라이언트
```javascript
	manager = aPerson.department.manager;
```
> 클라이언트에서 어떤 사람이 속한 부서의 관리자를 알고 싶어한다. 클라이언트는 부서 클래스가 관리자 정보를 제공한다는 사실을 알아야한다. 이러한 의존성을 줄이려면 클라이언트가 부서 클래스를 볼 수 없게 숨기고, 대신 사람 클래스에 간단한 위임 메서드를 만들면 된다. 


## 수정된 코드
### Person class
```javascript
class Person{
	...
	//manager 메서드 추가
	get manager(){return this._department.manager;}
	...
}
```

### 클라이언트
```javascript
	manager = aPerson.manager;
```

>p.271
>중개자 제거하기
>위임 숨기기는 위임 객체를 캡슐화하는 이점을 갖고있으나 위임을 위해 단순 전달만 하는 메서드를 계속 추가해야할 수 있다. 그러면 서버 클래스는 그저 중개자로 전락하여 차라리 클라이언트가 위임 객체를 직접 호출하는 게 나을 수 있다.
