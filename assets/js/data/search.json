[ { "title": "[Typescript] 타입스크립트 도입 시작", "url": "/posts/typescript101_part1/", "categories": "Typescript", "tags": "Typescript", "date": "2022-09-13 16:56:00 +0900", "snippet": "타입스크립트를 배우게된 이유 자바스크립트로 코드를 짜면서 런타임 에러를 너무나 자주 만나게 됐다. 있어서는 안되는 입력되는 데이터 형식의 오류를 막을 수 있다. JS는 동적타입언어고 TS는 JS에 타입이 정해진 superset으로 정적타입언어로 컴파일시 타입에러를 잡을 수 있다.타입스크립트를 사용해야하는 이유 위에서 말했던 바와 같이 정적타입언어이기 때문에 컴파일시 타입 에러를 잡을 수 있다. 개발 하는 도중에 에러에 대한 확인을 받을 수 있기 때문에 앱을 실행하면서 발생하는 오류를 줄이고 자신감을 얻을 수 있다. 또한 타입스크립트에서 자체 제공하는 컴파일러나 Babel로 타입스크립트 코드를 transcompile해서 자바스크립트 코드로 변환시켜주기때문에 자바스크립트가 사용되는 환경이면 어디든 사용할 수 있다. 따라서 기존에 자바스크립트로 작성된 코드를 점진적으로 타입스크립트 코드로 변환시킬 수 있다. 객체지향언어이기 때문에 유지보수성이 좋다.따라서 기존에 JS로 작성해놓은 코드를 TS로 수정할 생각이다.typescript를 글로벌 설치한다.npm install -g typescripttsc -v" }, { "title": "[Test] part.2 Jest", "url": "/posts/test_part2/", "categories": "Test", "tags": "Test, Jest", "date": "2022-09-04 21:00:00 +0900", "snippet": " 테스트 피라미드 3단계의 가장 밑바탕이되는 unit test를 먼저 시작한다.Jest 자바스크립트에서 주로 사용되는 테스트 라이브러리이다. create-react-app으로 react 프로젝트를 생성시 함께 설치되는 라이브러리이기 때문에 React 환경의 테스트를 앞서서 vailla javascript를 Jest로 테스트한다.Jest 환경설정 Jest는 javascript 환경에서 사용해야하기 때문에 node js을 사용할 수 있도록 npm 환경을 설정한다. npm init --yes npm 환경설정이 완료되면 package.json파일이 생성되고 Jest 를 설치한다. npm install jest --global jest 시작 + jest.config.js 파일 설치 jest --init jest.config.js 관련 정보 jest 함수의 사용법을 쉽게 파악하기 위해 jest 타입을 설치한다. jest타입을 설치하면 package.json에 @types/jest dependency가 설치되고 jest관련 함수를 사용하고 ctrl + click(cursor)를 누르면 사용법을 확인할 수 있다. npm install @types/jest package.json에 jest script 추가 \"scripts\": { \"test\": \"jest\", \"clear_jest\": \"jest --clearCache\"}, npm run test 로 jest를 실행, npm run clear_jest로 기존의 jest 수행결과 cache를 삭제한다. 함수 테스트함수 테스트를 위해 mock 함수을 사용한다. Mock functions are also known as “spies”, because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.mock은 ‘스파이’라고 알려져있다. mock은 결과값을 테스트하는게 아니라 다른 함수로부터 간접적으로 불리는 함수의 행동을 감시한다.jest.fn()로 mock 함수를 만들 수 있고 implement 가 없으면 undefined를 return 한다.mock은 함수를 태스트하기 위해 가짜(mock)으로 함수를 대체하는 기법을 말한다.일반적으로 테스트하려는 코드가 의존하는 부분을 직접 생성하기가 부담스러운 경우 mocking이 사용된다.check.jsfunction check(predicate, onSuccess, onFail) { if (validate()) { onSuccess(\"yes\"); } else { onFail(\"no\"); }}module.exports = check; 함수를 정의하고 테스트하기 위해 export 설정을 한다.check.test.jscheck.js 테스트하기위해 먼저 check.js를 import한다.const check = require(\"../check\");한 함수에서 다양한 상황을 테스트하기 위해 describe로 묶는다. 모든 테스트는 ‘check’라는 이름으로 묶인다.describe(\"check\", () =&gt; { ...});describe내부에서 각 테스트별로 테스트 시작전에 공통적으로 불리는 코드는 beforeEach()로 묶어서 재사용성을 높인다.it 혹은 test로 테스트할 상황을 정의하고 첫번째 인자로 상황을 정의하는 문장을 , 두번째 인자는 테스트 코드 함수를 받는다.describe(\"check\", () =&gt; { let onSuccess; let onFail; beforeEach(() =&gt; { onSuccess = jest.fn(); onFail = jest.fn(); }); it(\"should call onSuccess when validate is true\", () =&gt; { ... }); it(\"should call onFail when validate is false\", () =&gt; { ... });});각 테스트 별로 check함수를 부르고 expect를 통해 기대하는 결과를 작성한다.테스트 별로 기대하는 결과는 expect 함수의 matcher를 사용해 테스트에 기대하는 결과값을 비교한다.//it 혹은 test로 테스트할 상황을 정의하고 첫번째 인자로 상황을 정의하는 문장을 , 두번째 인자는 테스트 코드 함수를 받는다.it(\"should call onSuccess when validate is true\", () =&gt; { check(() =&gt; true, onSuccess, onFail); //expect(onSuccess.mock.calls.length).toBe(1); expect(onSuccess).toHaveBeenCalledTimes(1); //expect(onSuccess.mock.calls[0][0]).toBe('yes'); expect(onSuccess).toHaveBeenCalledWith(\"yes\"); //expect(onFail.mock.calls.length).toBe(0); expect(onFail).toHaveBeenCalledTimes(0);});it(\"should call onFail when validate is false\", () =&gt; { check(() =&gt; false, onSuccess, onFail); //expect(onFail.mock.calls.length).toBe(1); expect(onFail).toHaveBeenCalledTimes(1); //expect(onFail.mock.calls[0][0]).toBe('no'); expect(onFail).toHaveBeenCalledWith(\"no\"); //expect(onSuccess.mock.calls.length).toBe(0); expect(onSuccess).toHaveBeenCalledTimes(0);});fail하도록 수정한 코드fail 결과 캡쳐화면 테스트에서 기대하는 결과가 나오지 않으면 fail과 함께 should call onSuccess when predicate is true테스트에서 틀렸다는 것을 확인할 수 있다. 테스트 코드는 의도된 대로 작성되었지만 구현 코드가 잘못되어 실패했다면 테스트가 통과할 때까지 구현 코드를 수정한다.클래스 테스트user_service.jsclass UserService { constructor(userClient) { this.userClient = userClient; this.isLogedIn = false; } login(id, password) { if (!this.isLogedIn) { return this.userClient .login(id, password) .then((data) =&gt; (this.isLogedIn = true)); } }}module.exports = UserService;기존의 코드는 user_service.js 내부에 fetch 함수로 데이터를 받아왔다.하지만 네트워크에 의존하는 코드는 mock 또는 stub으로 따로 테스트를 하기위해 UserClient클래스로 분리한다.그리고 UserService 클래스에서는 userClient에 분리된 함수가 네트워크연결되어 데이터를 받아 올 경우 login 상태를 true로 변경한다.user_client.jsclass UserClient { login(id, password) { return fetch(\"http://example.com/login/id+password\") // .then((response) =&gt; response.json()); }}module.exports = UserClient;UserClient 클래스 내부에 비동기 login함수를 만들고 데이터를 받아온다.user_service.test.jsconst UserService = require(\"../user_service\");const UserClient = require(\"../user_client\");jest.mock(\"../user_client\");describe(\"UserService\", () =&gt; { const login = jest.fn(async () =&gt; \"success\"); //UserClient에서 login함수를 불러온다. UserClient.mockImplementation(() =&gt; { return { login, }; }); let userService; beforeEach(() =&gt; { userService = new UserService(new UserClient()); // login.mockClear(); // UserClient.mockClear(); //jest config clearMocks: true 설정을 해놔서 mockClear를 안해도 됨 }); it(\"calls login on UserClient when tries to login\", async () =&gt; { await userService.login(\"abc\", \"abc\"); expect(login).toHaveBeenCalledTimes(1); }); it(\"should not call login() on UserClient again if already logged in\", async () =&gt; { //기존에 로그인 되어있다면 로그인을 시도해도 login 함수가 한번 불려진다. await userService.login(\"abc\", \"abc\"); await userService.login(\"abc\", \"abc\"); expect(login).toHaveBeenCalledTimes(1); });});module.exports = { // All imported modules in your tests should be mocked automatically // automock: false, // Stop running tests after `n` failures // bail: 0, // The directory where Jest should store its cached dependency information // cacheDirectory: \"C:\\\\Users\\\\jooheek\\\\AppData\\\\Local\\\\Temp\\\\jest\", // 모든 테스트가 시작하기 전에 mock call, instance, context, result를 모두 리셋해주는 설정이다. clearMocks: true, // 테스트 가 얼마나 코드를 cover하는지 수치를 보여주는 설정이다. collectCoverage: false,};jest.config.js에서 테스트 간의 mock함수 독립성을 위해 clearMocks 설정을 true로, 테스트 결과를 간결하게 보기 위해 npm run test하면 항상 나왔던 프로젝트 당 coverage를 false로 설정한다.💡참고 [Jest] jest.fn(), jest.spyOn() 함수 모킹" }, { "title": "[Test] part.1 Test Pyramid", "url": "/posts/test_part1/", "categories": "test", "tags": "test", "date": "2022-09-02 11:00:00 +0900", "snippet": "많은 프로젝트에서 TDD를 도입하고 있고, JD에도 TDD 주도 개발을 경험해본 인재를 찾기에 테스트 주도 개발이란 무엇인지 궁금해졌다. 궁금한건 못참기 때문에 역시나 궁금증을 풀기위해 테스트에 발을 담가보았다.그리고 이번 기회에 아직 테스트를 실전 프로젝트에서 사용해보지 못해 부족한 부분도 많겠지만 드디어 테스트에 대한 개념정리와 테스트를 해야하는 이유, 테스트의 종류와 테스트를 진행할 때 사용하는 라이브러리의 사용법을 배웠기 때문에 잊기 전에 정리해본다.테스트를 해야하는 이유 테스트 코드는 기능 코드를 구현하기 전에 먼저 작성한다. 따라서 테스트 코드를 작성하면서 기능 구현 전에 발생할 수 있는 버그를 먼저 확인하고 기능 코드를 작성해 버그를 줄일 수 있다. 테스트 코드를 작성하면서 앞으로 작성할 코드가 요구사항에 맞는지 확인할 수 있다. 테스트 코드로 요구사항에 맞는 코드를 작성할 수 있는지 확인하고 코드 작성의 청사진을 만들 수 있다. 테스트 코드의 성능 결과를 보고 코드의 성능이 빨라지기 위해 어떻게 코드를 작성해야하는지 테스트해볼 수 있다. 테스트 코드를 작성하기 위해서는 코드간의 의존성이 낮아져야하는데 코드를 리팩토링하면서 코드의 의존성을 낮출 수 있다. 테스트를 통해 코드가 어떤 의도로 작성되었는지 쉽게 확인할 수 있다.Test Pyramid테스트는 크게 3단계로 나뉜다. Unit Test -&gt; Integration Test -&gt; E2E Test Unit Test : 함수, 모듈, 클래스 단위의 테스트를 일컫는다.Integration Test : 여러 Unit들을 통합했을 때 서로의 상호작용이 의도한 대로 진행되는지 테스트하는 과정을 말한다.E2E Test : UI 테스트, 사용자 테스트라고도 부른다. 앱을 사용할 때 사용자가 실제 앱을 사용할 때와 유사한 환경에서 테스트한다. 최종 테스트이다.피라미드의 상단으로 올라갈 수록 비용이 높아지고 시간이 많이 소요되기 때문에 Unit test, Integration를 통해 비용과 시간을 적게 쓰는 테스트 코드를 작성하는 것이 중요하다.회사와 프로젝트에 따라 다르지만 개발자가 모든 테스트 단계에 대한 테스트를 작성하기도 하고 아니기도하다.따라서 테스트 코드를 작성할 생각이라면 어느 단계까지 테스트 코드를 작성할지 정하고 시작하는 것이 좋다.💡 참조 martin folwer.com The Practical Test Pyramid" }, { "title": "[React] PureComponent, memo", "url": "/posts/react_performance_optimization/", "categories": "React", "tags": "React, PureComponent, memo", "date": "2022-08-31 11:00:00 +0900", "snippet": "React Virtual DOM React는 Component에 관련된 state, props이 변경되는 경우 랜더가 호출된다. state, prop이 변경되면 메모리상에 존재하는 Virtual DOM tree에 이전의 prop과 state로 구현된 tree와 새로 구현된 tree를 비교해서 변경된 부분만 DOM에 업데이트한다. 문제는 변경되지 않은 Component도 랜더링되기도 하는데 변경사항 없는 요소를 다시 읽어오는 것은 메모리를 낭비하며 성능을 저하시킨다. 따라서 이런 변경이 필요하지 않은 Component들의 랜더링을 막기 위한 성능 최적화가 필요하다.React 성능 최적화 React 성능 최적화를 위해서는 class를 사용할때는 Component를 PureComponent로, 함수형일때는 함수를 memo로 감싸주는 방법이 있다. 두 방법 모두 내부 로직에서 props 와 state가 변하지 않는 상황에서 불필요한 랜더링을 막아서 앱의 성능을 향상시킨다는 장점이 있다. 하지만 PureComponent와 memo를 분별없이 사용할 경우 오히려 성능이 저하될 수 있기때문에 주의가 필요하다.React Developer Tools 설치 컴포넌트의 랜더링은 React Developer Tools로 확인할 수 있다. 이 확장 프로그램은 React 앱일 경우에만 개발자 도구 탭에 보인다. Chrome 웹 확장 프로그램 &gt; React Developer Tools 다운 Components 탭 설정(⚙) 팝업에서 highlight updates when components render를 체크하면 component가 랜더될때마다 랜더되는 component들이 하이라이트된다. 이제 랜더링될 필요가 없는 component 들을 확인해 성능 최적화해준다. PureComponent class가 Component를 extend할때 성능 최적화를 위해 적용할 수 있는 방법이다. PureComponent는 shouldComponentUpdate()함수를 이용해 prop, state를 (이전의 Virtual DOM tree와의) 얕은 비교로 어떤 요소를 업데이트해 DOM에 전달할지 판단한다. PureComponent 사용시 주의사항 : PureComponent 는 shouldComponentUpdate()으로 prop의 변화 여부를 확인하는데 만약 전해지는 prop이 매번 변할 경우 shouldComponentUpdate()을 쓸데없이 불러오게되어 매번 체크하게되어 오히려 성능이 떨어지게 된다. class Mouse extends React.PureComponent { // Same implementation as above...}class MouseTracker extends React.Component { render() { return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; {/* 매번 랜더링할 때마다 Mouse class에 전달하는 prop이 변경된다면 Mouse class가 PureComponent를 extend하지 말아야한다. */} &lt;Mouse render={(mouse) =&gt; &lt;Cat mouse={mouse} /&gt;} /&gt; &lt;/div&gt; ); }}memo 공식문서에는 오직 성능 최적화를 위해 사용되기 때문에 랜더링을 방지하기 위해 사용하지 말라는 경고 메시지가 있다. 랜더링을 막기 위해 무분별하게 사용하지 말라는 의미 같다. memo 를 사용해야할 때는 Use React.memo() wisely 컴포넌트가 같은 값이 주어지면 항상 같은 결과가 나올 때 컴포넌트 랜더링이 자주 될 때 항상 같은 props로 랜더링 될 때 컴포넌트가 커서 랜더링시 시간이 오래 걸릴 때 const Card = memo(({ card }) =&gt; { ... return ( ... );});" }, { "title": "[React] useState callback", "url": "/posts/react_useState/", "categories": "React", "tags": "React, useState", "date": "2022-08-29 21:40:00 +0900", "snippet": "useState callbackconst createOrUpdate = (card) =&gt; { const updated = { ...cards }; updated[card.id] = card; setCards(updated);}; 기존의 코드는 이렇게 작성되어 있었다. 문제는 원하는 대로 실행되지 않았다는 것이다. 코드 작성의도는 수정된 card의 정보들이 update 변수에 담겨 setCards()함수로 card 의 상태를 업데이트 하는것이 었으나 수정된 사항이 card에 반영이 안됐다. 수정하기 전 state가 자꾸 불러져왔다. 이유는 setCards()함수가 비동기적으로 동작하기 때문이다. 따라서 상태를 동기적으로 업데이트하기 위해서는 useState에서 제공하는 callback을 사용하면 된다. Reactjs setState() 비동기 관련 문서 에 따르면 이렇게 바꿀 수 있다. 따라서 setCards()내부에서 이전의 cards를 받아서 state를 수정해서 업데이트한 정보를 return한다.const createOrUpdate = (card) =&gt; { setCards((cards) =&gt; { const updated = { ...cards }; updated[card.id] = card; return updated; });};" }, { "title": "[React] useRef, useHistory", "url": "/posts/react_hooks/", "categories": "React", "tags": "React, useRef, useHistory", "date": "2022-08-22 15:15:00 +0900", "snippet": "useRef 함수형 컴포넌트에서 ref를 사용할 때는 useRef hook을 사용한다.(클래스형 컴포넌트에서는 React.createRef를 사용한다.) useRef()를 사용하여 Ref 객체를 만들고, 선택하고 싶은 DOM 에 ref 값으로 설정한다. Ref 객체의 .current 프로퍼티는 선택한 DOM 의 값을 뜻한다. useRef는 내용이 변경될 때 변경된 값을 알려주지 않기때문에 React가 DOM 노드에 ref를 attach하거나 detach할 때 어떤 코드를 실행하고 싶다면 대신 콜백 ref를 사용해야한다.function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =&gt; { // `current` points to the mounted text input element inputEl.current.focus(); }; return ( &lt;&gt; &lt;input ref={inputEl} type=\"text\" /&gt; &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt; &lt;/&gt; );}useHistory react의 hook이 아닌 react-router-dom hook이다. 최신버전인 react-router ver.6 는 useHistory()를 더이상 지원하지 않는다. 따라서 useNavigate()를 사용해보려고 했으나 공식 사이트 useNavigate 항목에 404가 떠서 급 방향을 틀었다. 공식 문서에 404가 뜨는데 섵부르게 사용할 순 없다는 생각이 들었다. 2022-08-28 현재는 docs는 여전히 404, hooks 분류에는 정보가 업데이트 되어있다. React-router useNavigate() 공식 문서 공식 문서를 보면 이렇게 사용한다. useHistory()와 마찬가지로 첫 arg는 이동하는주소를 입력받고 두번째 arg는 선택입력사항으로 replace 또는 state를 이동하는 주소에 보낼 수 있다. { replace: true } 를 사용한다면 페이지가 이동된 후 뒤로가기를 하더라도 기존 페이지로 넘어오지 않고 메인 페이지(‘/’)로 돌아간다. { replace: false } 인 경우 뒤로가기가 가능하며 replace 속성을 명시하지 않으면 false가 기본값이다. import { useNavigate } from \"react-router-dom\";function SignupForm() { let navigate = useNavigate(); async function handleSubmit(event) { event.preventDefault(); await submitForm(event.target); navigate(\"../success\", { replace: true }); } return &lt;form onSubmit={handleSubmit}&gt;{/* ... */}&lt;/form&gt;;} useHistory 훅은 이렇게 사용한다. push 함수를 사용해 주소와 state를 전달 할 수 있다.const Maker = ({ authService }) =&gt; { const history = useHistory(); const onLogout = () =&gt; { authService.logout(); }; useEffect(() =&gt; { authService.onAuthChange((user) =&gt; { if (!user) { history.push(\"/\"); } }); }); return(... )};" }, { "title": "[TED] how to write less but say more", "url": "/posts/tedtalk_how_to_write_less/", "categories": "TED", "tags": "TED, TED talk", "date": "2022-08-22 15:15:00 +0900", "snippet": " 대부분의 사람들은 당신이 어떤 이야기를 하는지 관심갖지 않는다. 아무리 중요한 내용이라도 대부분의 사람들은 긴 기사를 읽지 않는다. 기사의 끝부분에 요점을 적어놨다면 아마 그 요점은 읽히지 않았을 것이다. 과거에는 조간신문과 백과사전, 9시 뉴스 등으로 정보를 얻었을지 몰라도 최근엔 모든 정보를 공짜로 손쉽게 접근할 수 있다. 대부분의 사람들은 동시에 많은 것들에 집중할 수 없다. 너무 많은 정보들이 주목이 필요한 정보를 가리고 있다. 여러분이 전달하고자 하는 정보를 눈에 띄게 만들어야 한다.Stop being selfish 계속 당신이 중요하다고 생각하는 것에 대해 글을 쓰는건 이기적이다. 당신 자신을 위한 글을 쓰지 말라. 독자들이 진짜로 알아야되는것은 무엇인가? 어떻게 내용을 전달할 것인가에 대해 집중해야한다. 글을 길게 작성하면 독자들은 글을 읽지 않는다.26초의 짧은 순간에 전할 딱 한가지는 무엇인가? 사람들은 새로운 콘텐츠에 보통 26초의 시간만을 투자한다. 짧은 시간에 정보를 습득할 수 있도록 간결하게 글을 작성해야한다. 어려운 단어, 이해하기 힘든 단어로 당신의 지식을 자랑하지 말고 바로 포인트로 들어가라. 가장 적은 단어로, 적은 문장으로, 인간적이게 정보를 전달하라.개발에도 적용할 포인트 특히나 프론트 엔드 처럼 사용자들에게 직접적으로 영향 끼치는 분야에 중요한 요소라고 생각한다. 아무리 환상적인 기능을 구현해도 사용자가 사용하기 힘들고 이해하기 힘든 숨겨진 기능이라면 개발한 가치가 있을까? 적은 요소로 눈에 잘 보이게 서비스에서 제공하는 바가 무엇인지 파악할 수 있는 개발을 하는게 중요하다고 생각한다. 접근하기 쉽게, 짧은 시간에 사용자가 파악할 수 있도록 기능을 구현하자." }, { "title": "[CSS] 잡다한 팁", "url": "/posts/css101_part8/", "categories": "CSS", "tags": "CSS, class, height, psuedo-class, display", "date": "2022-08-16 15:15:00 +0900", "snippet": "css 잡다한 팁클래스 명에 통일성 주기 제목, 내용과 관련된 요소는 @@-title, @@-content 와같이 통일된 클래스 명을 사용한다. 재사용성을 생각하고 css를 짜야함. 그래야 클래스 명만 봐도 어디에 쓰이는지 알기 쉽다. height: auto; 웹화면 content 작성할 때 요소들의 높이만큼 부모요소의 크기 정하기.landing-content { height: auto; /* padding: 120px 0; */}가상클래스 적극적으로 활용하기 bootstrap css을 활용한다면 bootstrap 의 기본 틀인 container, row, col 클래스 설정을 건들이지 말것 꼭 필요하다면 가상클래스를 사용하자. 굳이 새로운 클래스 이름을 짓지 말것.MDN pseudo class, pseudo element 관련 문서 내 블로그 pseudo class 관련 포스트.service .col-12:first-child { /* service &gt; col-12 &gt;의 첫번째 요소에 적용되는 css */}분리되는 섹션별로 섹션명 주석달기 코드치는 순간에도, 다시 꺼내볼 때도 섹션별로 주석이 달려있으면 ctrl + f 로 검색했을 때 찾기 쉽다./* landing *//* service */display 확인하기 css를 적용했는데 display가 적용되지않았다면 해당 요소 의 display에 적용되지 않은 속성을 추가했기 때문일 수 있다. 예를 들어 display : inline; 는 width, heigth, padding(top &amp; bottom), border(top &amp; bottom), margin(to &amp; bottom)를 사용할 수 없다. 이럴 땐 display : block; 으로 display 속성을 바꾸거나 css가 적용되는 다른 tag를 찾아본다.띄어쓰기, 오타, tag 위치 확인하기 css는 오류 경고가 뜨지 않기 때문에 css가 적용이 안되면 어디가 잘못되어있는지 확인하기 어렵다. 때문에 tag가 제대로 된 위치에 있는지, 띄어쓰기가 제대로 되었는지, 오타가 나진 않았는지 확인해야한다. html과 css를 양 옆에두고 위에서 아래로 차근차근 훑어보자. 분명 잘못된 곳이 있다. 오타, 띄어쓰기에 자신이 없다면 자동완성 기능을 쓰자언제나! 💡 개발자도구 &gt; element &gt; styles &amp; computed 로 확인하기 뭐가 적용됐는지, 안됐는지는 이것만 봐도 확인 가능" }, { "title": "[CSS] selectors, grid system, bootstrap, reset css", "url": "/posts/css101_part7/", "categories": "CSS", "tags": "CSS, selectors, grid system, bootstrap, reset css", "date": "2022-08-15 15:40:00 +0900", "snippet": "selector html 요소를 직접 지칭p { ...;}blockquote { ...;} class selector : 같은 css를 선언하고 싶은 요소들의 class 이름을 동일하게 부여하는 것이 좋다..box { ...;}.box.red { ...; /*class명이 box와 red인 요소에 주는 css*/} id selector : id는 class와 다르게 단 하나의 요소에만 사용돼야한다. child section h1 { /*section 밑에있는 모든h1 자손들에게 적용되는 css*/}section &gt; h1 { /*section 의 자식인 h1에게만 적용되는 css*/} sibling combinators.active ~ li { /*active class 밑에있는 모든 li들에 적용되는 css*/}.active + li { /*active class 바로 밑에있는 li 하나에만 적용되는 css*/} structural psuedo-classes : 가상클래스 first-child, last-child, nth-child li:first-child { /*첫번째 li 요소에만 적용되는 css*/}li:last-child { /*마지막 li 요소에만 적용되는 css*/}li:nth-child(3) { /*세번째 li 요소에만 적용되는 css*/}li:nth-child(2n) { /*짝수의 li 요소에만 적용되는 css*/}li:nth-child(2n-1) { /*홀수의 li 요소에만 적용되는 css*/} user action psuedo class : 사용자의 액션에 따른 가상 클래스 hover, active, focus a:hover { /*마우스가 올라갔을 때 적용되는 css*/}a:active { /*눌렀을때 적용되는 css*/}input:focus { /*input 박스에 입력할 준비가 됐을때 적용되는 css*/} 우선순위 나중에 선언된 요소가 먼저 선언된 요소를 덮는다. id &gt; class (가상클래스 포함) &gt; type 순으로 css 적용 우선순위이다. 위의 우선순위를 제치는 방법은 inline-style -&gt; html tag 에 스타일을 작성하는 것이다. inline style 은 css 파일에서 확인이 불가능하기 때문에 추후 수정시 확인할때 시간이 오래걸릴 수 있다. 🙏 제발… css파일에 그냥 작성하자. !important …는 위의 모든 것보다 우선시 된다. 정말 중요한 것이 아닐때는 사용하지 말것 grid system container, column, gutterbootstrap bootstrap : grid system으로 구현된 깔끔한 template 반드시 container &gt; row &gt; col 구조로 구현되어야한다. col-12를 차지하는 요소를 만들고 싶다면 col-12 클래스 내부에 구현해야함. 부트스트랩 layout breakpoint를 보고 화면넓이가 변할때의 사이즈를 클래스 명으로 정할 수 있다. 이걸 예전 파이널 프로젝트 구현할 때 알았어야하는데… 전혀 몰라서 반응형이고 뭐고 반영을 제대로 못한듯&lt;div class=\"col-12 col-sm-6 col-md-4 col-lg-3\"&gt;&lt;/div&gt;가장 작은 사이즈(넓이 576px 이하)일때 12개의 column을, 그다음 사이즈일때(넓이576px 이하상 768px이하) 6개, 그 다음(넓이 768px이상 992px이하)은 4,마지막(992px이상 1200px이하)은 3 를 차지하는 div bootstrap css를 사용하기 위해서는 Bootstrap intoduction 문서설명대로 다운받고 설치하는 과정이 필요하다… 하지만 bootstrap grid만 사용할거라면 m-spyratos/bootstrap-4-grid github 주소여기서 파일을 ctrl + c하고 프로젝트에 grid.min.css파일을 생성하고 그대로 넣으면 된다.( + index 파일에 link 삽입해서 적용하는 과정 잊지말것) flex property 를 클래스로 추가할 수 있다. bootstrap은 flexbox 기반으로 구현되어있고 flexbox 관련 property 들은 클래스를 추가해서 사용할 수 있다. Bootstrap justify-content 관련 문서 justify-content 뿐만 아니라 direction, align-items, margin, wrap, align-content 까지 클래스를 추가해서 구현 가능하다. Bootstrap CSS : class 명을 추가하는것 만으로도 css를 대체할 수 있다. Bootstrap grid 화면 breakpoint 별 적용되는 grid 클래스 명, Bootstrap media query breakpoint별 미디어 쿼리, bootstrap에서 제공하는 Bootstrap background helper class 그리고 그 외 html tag 요소에 적용되는 class 요소들이 있으니 관련 문서를 참고하면 bootstrap으로 css를 편하게 적용할 수 있다. React Bootstrap 공식 문서 : react 에서 boostrap을 사용할 경우 npm install react-bootstrap bootstrap 혹은 npm install bootstrap@5.2.0(vanilla bootstrap)를 설치하면된다. 후자의 경우 bootstrap sass를 직접 작성하고 싶거나 stylesheet의 CDN을 사용하고 싶지 않을때 설치한다. css를 적용할 경우 import 가 필요하다. { /* src/index.js 혹은 App.js file 에 하단의 bootstrap 설정이 import되어있지 않다면 직접 설정해야한다.*/}import \"bootstrap/dist/css/bootstrap.min.css\"; bootstrap의 layout을 사용할거라면 app.js을 Themeprovider로 감싸야한다. Bootstrap custom breakpoints import ThemeProvider from \"react-bootstrap/ThemeProvider\";&lt;ThemeProvider breakpoints={[\"xxxl\", \"xxl\", \"xl\", \"lg\", \"md\", \"sm\", \"xs\", \"xxs\"]} minBreakpoint=\"xxs\"&gt; &lt;div&gt;Your app...&lt;/div&gt;&lt;/ThemeProvider&gt;; reset css Eric meyer’s reset css 유명한 reset css이다. 이 코드와 더불어 기본적으로 공통 css 선언이 먹히지 않는 textarea, input, button 등의 form element에 관한 reset css를 작성하는 것이 좋다. 만약 작성한다면 최상단에 위치할것. 각 타입 요소별로 공통적으로 사용되는 css가 있다면 reset css로 먼저 선언하면 된다./* Reset css */a { color: inherit; text-decoration: none;}button,textarea,input { font-family: ...; font-size: 16px;}ol,ul,li { list-style-type: none; padding-left: 0; margin-left: 0;} 모든 코드 작성법이 그렇듯이 reset css를 사용하지 않는 것이 나은 경우도 있다. 다른 css 요소와의 조합을 고려할것. 기존에 작성된 css가 있는데 이를 무시하고 reset하면 기존의 css가 적용되지 않기 때문에 문제가 발생한다." }, { "title": "[CSS] box shadow, opacity, overflow, transform, visibility", "url": "/posts/css101_part6/", "categories": "CSS", "tags": "CSS, box shadow, opacity, overflow, transform, visibility", "date": "2022-08-15 14:50:00 +0900", "snippet": "box shadow 요소의 그림자를 만들어주는 속성 neomorphism이 유행했다? 한다 하더라… 아이폰 감성인듯 h-offset, v-offset, (blur), (spread), color 를 작성해야한다. transition과 같이 사용해서 요소에 hover하면 효과를 나타내기도 한다..cancel-button { background-color: red; transition: box-shadow 250ms ease-in;}.cancel-button:hover { box-shadow: 0 10px 16px 0 rgb(0, 0, 0);} 요즘 ui 툴에는 box-shadow를 만들어주기도 한다. neomorphism box shadow를 만들어주는 사이트opacity 0(완전 투명) ~ 1(완전 불투명)overflow 자식요소가 부모요소를 벗어났을 때 어떻게 처리할지에 관한 속성 visible(기본값. 넘쳐흐르게 내버려둠), auto, scroll, hidden auto, scroll은 유사하다. 자식요소가 넘쳐날 경우 scroll을 만들어준다. hidden : 넘쳐날 경우 스크롤도 안되고 부모요소를 넘치는 부분은 볼 수 없게 가린다. overflow-x , overflow-y 속성 따로 설정 가능transform transform property는 굉장히 다양하기 때문에 다 다룰수 없다… 필요할때 알아서 검색하도록 MDN transform 공식문서 translate(), scale(), rotate() translate() : 자기 자신의 원래 위치를 기준으로 이동할 수 있게 한다. 이동해도 다른 요소들의 위치에 영향을 미치지 않는다. transform : translate(40px, 50px) 기존 위치에서 오른쪽으로 40px, 아래로 50px이동 음수라면 왼쪽으로, 위로 이동한다. transform : translate(100%, 100%)라면 자신의 가로,세로 값을 기준으로 100%이동한다. .card-carousel { position: relative;}#prev,#next { position: absolute; top: 50%; transform: translateY(-50%);} 부모요소(card-carousel)의 높이에서 가운데 위치하기 위해서 top : 50%;을 설정한다. 부모요소 길이의 1/2지점에 #prev와 #next 요소가 있기 때문에 #prev와 #next 요소의 길이만큼 아래로 치우쳐있어서 transform: translateY(-50%);를 추가해 부모요소의 정 가운데로 이동시킨다. scale(n) : n배 만큼 요소의 크기가 커진다. scale(x,y) : 가로 x만큼, 세로 y만큼 커진다. rotate( N deg ) : N 각도만큼 회전한다. visibility visible(기본값), hidden hidden : opacity : 0; 과 유사함 화면에 보이지만 않는다. 요소의 자리는 그대로 차지하고 있다." }, { "title": "[CSS] background, sr-only, transition, animation", "url": "/posts/css101_part5/", "categories": "CSS", "tags": "CSS, background, sr-only, transition, animation", "date": "2022-08-15 09:10:00 +0900", "snippet": "background background-color : hex, rgb, rgba background-image : url() 주소로 이미지를 넣을 수 있다. Unsplash.com 무료 이미지 다운 전송받는 image의 형태가 정해져있지 않다면 (가로 세로의 비율이 제각각인 경우) img 태그로 이미지를 받을 경우 수정해야할 css, js 코드가 지나치게 길어질 수 있다. 따라서 background-image : url(); 로 처리하는게 쉬운 방법일 수 있다. background-repeat : repeat, no-repeat. repeat이 기본값. background-repeat : no-repeat; 으로 이미지 반복을 막을 수 있다. background-size : contain, cover, custom. contain(이미지 잘리는 부분 없이 보여줌. 요소에 빈 공간이 생길 수 있다.) cover(요소안에 이미지를 꽉 채움. 이미지가 잘릴 수 있다.) background-size : 100% auto; 가로 100% 세로는 가로에 맞춰서 요소에 맞게 사이즈 자동 변경 background-size : 300px 50px; 이미지를 가로 300px, 세로 사이즈 50px로 늘리고 줄여서 사진을 변경한다. background-position : bottom, center, inherit px… x, y 설정 가능함. background-position : 50%, 50%; , background-position : center, center; 정 가운데에 위치 img { background-position: center, center; background-size: auto, 80%;}.card-image { ...; background-image: url(./assets/img-house.jpg); background-repeat: no-repeat; background-position: center center; background-size: cover; overflow: hidden;}// overflow: hidden; 이미지가 사이즈에 벗어날경우 이미지를 자름background image가 존재한다면 background-repeat, background-position, background-size 까지 4개 property 를 세트로 작성해주는 것이 좋다.sr-only 접근성을 위해 sr-only 클래스에 screen reader 사용자들을 위한 정보를 입력하고 sr-only 클래스에 css를 사용해서 웹 화면에서 안 보이게 하는 것이 좋다..sr-only { position: absolute; z-index: -100; width: 1px; height: 1px; overflow: hidden; opacity: 0;}//display : none; 은 웹 화면 뿐만아니라 screen reader에서도 읽을 수 없어서 사용하면 안됨transition property, duration, (timing-function), (delay) property : 어떤 property에 변화가 있을지 명시. font-size, background-color , all… duration : 변화의 지속시간 단위는 millisecond, second timing function : ease-in, ease-out, ease-in-out, cubic bezier() 앞의 세 function이 마음에 안든다면 원하는 타이밍을 만들 수 있다. cubic bezier delay : 효과를 일정 시간이 지나고 시작하게 한다. 1000ms : 1초 뒤에 transition 시작 요소의 여러 property에 다른 transition을 설정하고 싶다면 각 property별로 transition 설정 가능.box { ...; transition: font-size 1000ms ease-in, background-color 2500ms ease-out 1000ms;}.box:hover { font-size: 16px; background-color: blue;}// 모든 transition 요소를 같은 duration, timing function 으로 같은 한번에 적용하고 싶다면// transition property 에 all을 적용하면 된다./* .box { ...; transition: all 1000ms ease-in;} */animation transition은 property의 값이 스르륵 변할때 사용, animation은 animation을 주고싶을 때 사용. transition보다 적용할 수 있는 범위가 많다. keyframe 으로 적용 from - to, 0% - 50% - 100%(퍼센트는 임의로 정할 수 있음) 로 진행 단계를 정할 수 있다. animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction animation이 끝나면 기본 설정으로 돌아오기 때문에 animation을 설정하는 요소에 기본 설정을 작성해야한다.( background-color : blue; ).box { ...; background-color: blue; animation-name: move-box; animation-duration: 2000ms;}@keyframes move-box { from { ...; background-color: blue; } to { ...; background-color: red; }} animation-timing-function : transition의 timing function 과 같은 속성이 사용된다. ease-in, ease-out, ease-in-out, cubic bezier() animation-iteration-count : animation을 반복하는 횟수. 반복할 횟수(1,2,3 …), 혹은 ininite (무한 반복) animation-direction : animation의 진행방향. reverse, alternative, alternative-reverse, normal 번갈아서 사용할경우 animation-direction : reverse; 이외에도 다양한 property가 많기 때문에 공식문서 참조 MDN animation 공식문서" }, { "title": "[CSS] media query, viewport, font-size, letter-spacing, font-family, font-weight, color, webfont", "url": "/posts/css101_part4/", "categories": "CSS", "tags": "CSS, media query, viewport, font-size, letter-spacing, font-family, font-weight, color, text-align, text-transform, text-indent, text-decoration, webfont", "date": "2022-08-14 17:10:00 +0900", "snippet": "반응형 웹media query 화면의 길이가 768px 이상일때 적용되는 css@media screen and (min-width: 768px) { ...;} 화면의 길이가 768px 이상, 991px이하일때 적용되는 css@media screen and (min-width: 768px) and (max-width: 991px) { ...;} 띄어쓰기 잘하기… css 는 오류가 안나서 왜 적용이 안되는지 확인하기 쉽지 않다viewport meta&lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; 디바이스의 길이만큼의 viewport를 기준으로 한다. vw, vh : viewport height, viewport width 💡 모바일부터 시작하는 것이 정석이다. 작은 사이즈 부터 시작해서 큰 사이즈까지 코드를 작성할 것 가장작은 iphone 5 화면부터 시작하기typography 텍스트를 예쁘게 디자인하는 방법 font-size, baseline, line-height, letter-spacingfont- size px (고정된 값, 절대 단위), em, rem (상대 단위) em : 실제로 적용된 폰트사이즈, 기존에 px로 글씨 크기가 적용됐다면 em을 이용해 기존의 글씨크기에 비례해서 작거나 크게 만들 수 있다.보통 잘 사용하지 않음 rem : root(html) em. html에 적용된 글씨크기에 비례한 글씨 크기를 표현한다. line-height : 줄간격. px, em, rem 모두 사용가능 em을 자주 사용한다. font-size에 비례해서 크기가 정해지기 때문에 em, rem등의 용어가 생략되는게 관례이다. 글자는 언제나line-height 길이의 정 가운데에 배치된다. .text { font-size: 16px; line-height: 1.5;}letter-spacing px, em. 해당 폰트 사이즈에 비례해서 자간을 정하는게 좋은 관례라고 여겨짐. em이 자주 사용된다. line-height 와 달리 용어 생략하지 말것..text { font-size: 16px; line-height: 1.5; letter-spacing: -0.3em;}font-family 폰트 서체. if문 처럼 지정한 font-family가 존재하지 않으면 사용할 수 있는 font-family의 대안(fall-back font)을 정할 수 있다. 비슷한 류의 font-family를 대안으로 설정하는 것이 좋음 .text { font-family: \"Poppins\", \"Roboto\", sans-serif;} button, input, textarea 와 같은 form 요소의 경우 body에 선언된 font-family가 적용 안되는 경우가 존재하기 때문에 다시 명시해야한다.button,input,textarea { font-family: \"Poppins\", \"Roboto\", sans-serif;}font-weight 폰트의 굵기. regular : 400, bold : 700 이 관례다. 100단위임.color 폰트 색상 , hex, rgb, rgba(rgb + 투명도) 세가지 방식으로 설정할 수 있다. rgb 투명도 rgb(0,0,0) -&gt; 50%의 투명도를 원한다면 rgb(0,0,0,0.5) text-align 문자 정렬 left, right, centertext-indent 들여쓰기text-transform alphabet base 문자에만 사용가능. none, capitalize, uppercase, lowercasetext-decoration 텍스트에 줄을 긋는 설정. none, underlone, line-through, overlinefont-style 문자 스타일. italic이 주로 사용됨. normal, italic, oblique em tag의 기본 설정이 italic이다.webfont 구글폰트가 가장 유명함 원하는 폰트와 사이즈를 고르고 html에 link를 넣고 css에 font-family를 적용하면 된다. 만약 폰트를 다운받아서 사용하고 싶다면 폰트를 다운받고 font-face 설정을 해줘야한다. font-face 적용 방법font.css@font-face { font-family: \"NanumSquareRound\"; font-style: normal; font-weight: 400; src: url(\"./assets/fonts/NanumSquareRoundR.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */ url(\"./assets/fonts/NanumSquareRoundR.woff2\") format(\"woff2\"), /* Super Modern Browsers */ url(\"./assets/fonts/NanumSquareRoundR.woff\") format(\"woff\"), /* Pretty Modern Browsers */ url(\"./assets/fonts/NanumSquareRoundR.ttf\") format(\"truetype\"); /* Safari, Android, iOS */} font style과 weight별 font-face 를 작성하고 메인 css파일에 적용한다.html에 link로 font.css주소를 넣거나 css파일에 import 하면 된다.style.css@import url(\"./fonts.css\");body { font-family: \"NamumSquareRound\", san-serif;} 개발자도구 &gt; elements &gt; computed &gt; font-family 확인, 문자열 클릭 &gt; computed &gt; 하단 Rendered Fonts 확인, network &gt; font 에 파일 오고있는지 확인.container { width: 100%; max-width: 740px; padding: 48px; margin: 0 auto;}//어느정도까지는 넓이를 100% 사용( width : 100%)하고 싶지만// 적용하는 viewport 길이에 제한을 두고싶다면 max-width를 사용할 수 있다.//좌우 margin을 고르게 두고싶다면 margin : 0 auto;" }, { "title": "[CSS] position, flexbox", "url": "/posts/css101_part3/", "categories": "CSS", "tags": "CSS, position, transform, flexbox", "date": "2022-08-13 13:10:00 +0900", "snippet": "position position을 사용할 때는 어떤 종류의 포지션을 사용하는지, 무엇을 기준으로 위치해 있는지 확인해야함. static : 모든 요소의 기본 position. relative : 원래 위치를 기억하고 있다. 기존 위치를 기준으로 이동가능. 다른 위치로 이동되더라도 다른 요소들의 위치에 영향을 주지 않음. absolute : display를 block으로 바꿔준다. 다른 요소에 영향을 주는게 아니라 붕 떠있음. 영향을 안받는 절대적인 위치에 존재. position이 static이 아닌 부모요소를 기준으로 위치한다. 요소에 position: abosolute를 속성으로 추가하기 위해서는 부모요소에 position : relative 를 속성으로 넣으면 쉽다. fixed : absolute와 유사하다. absolute와의 차이점은 viewport가 기준점이라는 것이다. position: fixed; bottom: 0 ;으로 설정하면 스크롤을 내려도 화면 바닥에 붙어있다. sticky : 과거에는 지원하는 브라우저가 거의 없었다. Can i use sticky 검색 결과하지만 최신 브라우저에는 적용이되어가고있다. 노마드코더 position sticky 관련 영상, MDN position sticky 공식문서 관련 설명을 보면 하단으로 스크롤을 내려도 화면 상단에 보여야하는 배너나 게시물 목록, bread crumb을 만들 때 유용하게 사용되는듯 하다. z-index : 요소의 높이 a 요소와 b요소가 겹치는데 a요소가 위에 있는 것을 원할 경우 b의 z-index보다 높게 설정하면 된다. a { z-index: 2;}b { z-index: 1;} flexbox 정렬하고자하는 요소의 부모요소에 속성을 추가한다. display : flex; 또는 display: inline-flex; 어느방향으로 정렬할지 설정 flex-direction : row; row, row-reverse, column, column-reverse 가로축 정렬방향에 따라 요소를 정렬하고 싶을 때 justify-content MDN justify-content 관련 문서 center, flex-start, flex-end, space-between, space-around 세로축 정렬방향에 맞게 요소를 정렬하고 싶을 때 align-items, align-content MDN align-items 관련 문서MDN align-content 관련 문서center, flex-start, flex-end align-items : 각 라인의 수직축을 기준으로 정렬된다.align-items : start;라면 각 라인별 상단으로 정렬,align-items : center;라면 라인별 중앙에 위치한다. align-content : flex-wrap : wrap; 라서 요소들이 여러 라인으로 배치될 경우 사용된다. align-items와 달리 라인별로 정렬하는게 아니라 부모 요소 전체의 수직축에 따라 정렬된다. align-content: start;라면 모든 flexbox가 화면의 상단으로 정렬된다. align-items 와 align-content 를 설정하려는 요소들이 라인 하나에 모두 배치될 경우 두 property 모두 같은 기능을 한다. 하지만 라인이 두개 이상일 경우 라인별 배치를 고려한다면 align-items를 사용해야하고 라인이 아닌 부모 요소의 전체 영역상 배치를 고려한다면 align-content를 사용해야한다. 한줄안에 모두 정렬할 것인지 설정 flex-wrap : nowrap; wrap, nowrap nowrap : 자식요소의 width, heigth를 줄여서 한줄로 정렬한다. wrap : 부모요소의 width, heigth 크기가 충분하지 않으면 여러 줄로 만들어서 display한다. flex-basis : auto 가 기본값. 항목의 크기가 flex-basis의 크기이다. flex-grow : flexbox의 요소가 남는 공간을 자식요소들끼리 나눌때 분배 비율 flex-shrink : flexbox의 요소가 다른 요소와의 사이즈 경쟁에서 밀릴때 얼마나 줄어들어야하는지를 정하는 숫자. flex-shrink : 0; : 난 절대 안 줄이겠다. 내 사이즈에 맞게 다른 요소들 크기를 줄여라 flex-shrink 의 값이 1 이상이면 flex-basis에 지정된 사이즈보다 작아진다.MDN flexbox flex-shrink💡간혹 space-between 을 설정했을때 빈 공간이 많아도 요소들이 딱붙어있는 경우가 있는데 그럴때는 width : 100%;를 적어주면 width를 100% 사용해서 여유롭게 display 된다. float를 사용했던 코드.tab-menu { ...;}.tab-menu::after { content: \"\"; display: block; clear: both;}.tab-menu-item { float: left; ...;} flex로 변경한 코드.tab-menu { display: flex; /*flex-direction: row;*/ /*flex-wrap: nowrap;*/ /*justify-content: flex-start;*/ align-items: center; ...;}//기본값은 생략해도 된다. 이렇게 쉬울 수가 역시 float 사용하려면 너무 복잡해서 안 쓰는게 편하겠다고 생각 했는데 아주 쉬운 방법이 있었다. flex!!!" }, { "title": "[CSS] float, psuedo element", "url": "/posts/css101_part2/", "categories": "CSS", "tags": "CSS, float, psuedo element", "date": "2022-08-02 09:10:00 +0900", "snippet": "float 블록을 병렬적으로 배치하기 위해 사용한다. display : inline, inline block, block인 box에 float 속성을 추가하면 display: block 으로 변한다. 속성이 block이기 때문에 inline일때 사용하지 못했던 width, height, padding,margin…등의 속성을 적용할 수 있다. 하지만 기존 display:block 이었던 component들이 자신의 행에 margin을 둬 다른 component가 들어오는것을 막았던 것과 달리 float으로 block 속성을 적용할 경우 다른 component들이 box의 위치를 빙 둘러서 영역을 차지하게된다. 속성에 float 안 넣는게 더 쉽게 표현할 수 있을듯 너무 복잡함float 적용한 box 빙 둘러 다른 박스가 차지하는 것을 막는 방법 parent component에 overflow : hidden 속성을 추가한다..parent { width: 400px; margin: 0 auto; background-color: whitesmoke; overflow: hidden;}.parent::after { content: \"\"; display: block; clear: left;}.child { width: 200px; height: 200px; float: left; ...;}.red { background-color: red;}.blue { background-color: blue;}.green { background-color: green;} psuedo element를 만들어 clearfix 하기.MDN clear 속성 공식문서.parent { ...;}.parent::after { content: \"\"; display: block; clear: left;}.child { width: 200px; height: 200px; float: left; ...;}.red { ...;}.blue { ...;}.green { ...;} child component 세개가 float:left 이기 때문에 parent의 가장 마지막 자식을 pseudo로 만들고 display:block ( clear 속성을 사용하기 위해서는 display: block이어야한다 ), float:left 이기 때문에 clear : left 속성을 추가해준다. 동일한 내용의 clearfix를 중복해서 작성하는 것은 번거롭다. 따라서 clearfix 클래스를 따로 만들어서 clearfix가 필요한 곳에 clearfix class를 추가해주는 것도 좋은 방법이다..clearfix::after { clear: both; display: block; content: \"\";}psuedo element 가상요소 html의 틀을 구현하기 위해 사용하지 않는 빈 element를 작성하는건 좋지 않다.html을 위해 가짜 element를 css로 구현한다.MDN pseudo element 공식문서 content : \"\" content에 들어갈 내용이 없어도 content 요소를 필수로 작성해야한다. ::after는 선택된 요소에 마지막 자식을 만든다. content의 속성으로 cosmetic content를 만드는데 사용된다..child::before { content: \"😀\";}.child::after { content: \"😀\";}" }, { "title": "[월간회고] 일할 결심 ", "url": "/posts/monthly_report_july/", "categories": "월간회고", "tags": "월간회고", "date": "2022-07-31 21:11:00 +0900", "snippet": " 기술블로그에 기술 외적인 것도 써도 되나 싶지만 뭐 내 블로그니까 내 맘대로 가본다. 그동안 썼던 주간회고, 독서 기록들이 다 노션에 있어서 아쉽기도 하다. 주간회고를 올리는건 좀 껄끄럽고 월간회고는 월말마다 작성해보기로 한다. 적어도 올해 말까지는 꾸준히 작성하기 도전!😎 이번 편은 퇴사 후 공부하고 쉬고 취준한 이야기를 쓸 예정이다. 사실상 월간회고가 아니라 백수생활 회고가 되겠다 😁 흥미로 시작한, 발전을 위한 개발공부강의 부트캠프를 다닐 땐 이렇게 될 줄 몰랐다. Java를 배우고나니 Javscript는 너무 근본없는 언어같아서 꺼렸다. 문자열이랑 숫자를 더해도 오류가 안나고 클래스도 없고 prototype은 또 뭐고...! 머리만 복잡했는데... 그랬던 내가 JS에 관심이 생겼다. 업무할때 자주 쓰다보니 JS에 관심이 갔고 정신을 차려보니 '자바스크립트 딥다이브' 를 포함한 JS 관련 도서, 자바스크립트 강의를 구매하게 됐다. ES6 버전 JS,Web Api, 자바스크립트의 메모리 JS에서 타입이 적용된 Typescript와 React JS까지... 아직 다 보지는 않았지만 꾸준히 공부한 내용을 포스팅하며 미래의 나를 위해 새로운 정보를 기록할 예정이다. 지난 프로젝트할때 HTML,CSS는 건드릴수록 미궁으로 빠져들것 같다는 기분이 들었다. 세상에 버튼하나 원하는 위치에 원하는 모양으로 넣는다는게 이렇게 어려울 줄이야. React JS 프로젝트를 구현해보니 더욱 답이 없었다. HTML,CSS 지식 없이는 못난이 화면밖에 보여줄 수 없었다. 더이상 미룰수 없다는 걸 느끼고 강의를 구매했고 강의 내용과 함께 MDN에서 참고할만한 정보를 포스팅했다. 프론트 엔드 개발자가 되기 위해서는 프론트 지식 뿐만 아니라 웹 지식도 갖추고있어야한다. 그래야 API를 통해 백엔드에 데이터를 요청하고, 데이터를 받고 HTTP 상태코드를 보고 백엔드에서 요청이 정상적으로 전달됐는지 확인할 수 있다. 비정상적인 요청으로 받은 데이터는 화면에 노출하지 않거나 대체하는 정보를 제공하는 처리가 필요하다. 주기적으로 재확인하기 위해 기록해 놨다.도서1. 리팩터링 뛰어난 개발자들은 코드를 작성하는데 그치는 것이 아니라 리팩터링으로 기존의 코드를 더 명료하게 작성하기 위해 노력한다는데 그게 대체 뭔가! 나도 이 책을 보면 리팩터링 하게되는건가! 하는 호기심이 들어 읽게되었다. 개정된 2판은 자바스크립트 코드 기반이라 어떻게 JS 코드를 더 깔끔하게 작성할 수 있는지 서술되어있다. 공부할 방법을 모르겠어서 일단 한 챕터를 읽고 필요하다고 생각되는 문장을 따라 치면서 포스팅했다.2. 그 외의 개발 도서들 미처 포스팅하지 못한 것들이 많다. CS 지식을 위한 1일 1코드, 예약구매까지 했던 쏙쏙 들어오는 함수형 코딩, 코어 자바스크립트, 클린 코드 등 읽을 책들이 산더미라 읽기만 하면된다! 이번달의 내가 힘내기를 아자아자!!블로그에 꾸준히 포스팅 올림! 물론 블로그는 5월에 만든거긴하지만 최근엔 블로그를 꽤 유용하게 써먹고 있다는 생각이 들어 적어본다. 그동안은 공부한걸 나만 볼 수 있는 노션에 올렸다. 그동안 노션을 쓴 이유는 sql, JS, 그동안 읽은 개발도서 정리본을 다른 사람들에게 보이기에는 좀 민망했다. 다른 주제로 블로그를 운영해본 적이 없기도하고, 쓸만한 내용이 있나 싶었다. 하지만 남들 다한다는 기술 블로그 대체 어떤 이유 때문에 기술블로그를 만드는지 궁금했다. 나도 일단 만들어나 볼까 싶은 생각에 블로그를 만들었고 쓰다보니 개발 뿐만 아니라 마인드에도 도움이 됐다. 블로그 운영의 장점을 쓰다보니 너무 길어져서 접어봤다. 기술블로그 운영하면서 느낀 장점 포스팅을 작석하면서 공부한 내용을 더 체계적으로 정리하게된다. 노션에 적을 때는 메모와 비슷한 형식으로 대충 휘갈겨써서 나중에 알아보기 힘들 때도 있었다. 글도 개발과 비슷해서 내가 작성했더라도 몇개월 뒤에 다시 보면 알아보기 힘든 경우가 생긴다. 블로그에 글을 작성하면 혹시라도 다른 사람이 볼까봐, 미래의 내가 도움을 받을 때 이해하지 못할까봐 최대한 상세하게 체계적으로 작성하게된다. 코드의 흐름을 파악하는데 도움이 된다. 내가 작성한 코드를 문자로 정리하면서 왜 이걸 사용해야하는지, 관련된 문서는 어떤 것들이 있는지 다시 확인하게된다. 그 과정에서 개발할 때 보지 못한 새로운 문서와 블로그, stackoverflow를 검색했고 결국 이해에 도움이 됐다. 회고에 도움이 된다. 기록하지 않고 며칠, 몇 주가 지나면 내가 뭘 배웠는지, 어디를 더 파고들어야 하는지 잊어버리는 경우가 많다. 하지만 블로그에 글을 작성하게되면 블로그 아카이브 를 보고 대충이라도 확인이 가능하다. 과거에 쓴 글을 다시 읽고 어디가 부족했는지 확인가능하고 내가 허송세월을 보내지는 않았구나 라는 안도감(ㅋㅋ)도 받을 수 있다. 꾸준히 공부하게되는 원동력이 된다. 포스팅을 올리면 부족한게 눈에 보인다. 화면 구성도 빈약하고 내용도 빈약하다고 느낄 때가 많다. 자연스럽게 HTML,CSS,JS 를 넘어선 전반적인 CS에 대한 욕심이 생긴다. HTML, CSS, markdown 실습에 도움이 된다. 티스토리나 벨로그를 사용할 때는 HTML, css를 건드리지 않아도 됐는데 markdown 으로 작성하다보니 블로그 글을 쓰면서 부족한 점이 계속 눈에 들어오게되고 좀 더 깔끔한 스타일링에 욕심이 생긴다. 프론트엔드로 커리어를 지속하기 위해서는 HTML, css에도 항상 관심이 있어야한다고 생각하기 때문에 기존 플랫폼이 아니라 깃블로그를 만든것이 발전에 도움이 될것 같다. 이 블로그를 작성하면서도 새로 적용한 css와 HTML 지식이 꽤 많다.😊 오늘 포스팅에도 새로운 CSS를 적용하기도하고 기존의 CSS를 수정했다. 실패에 대한 두려움이 적어졌다. 블로그를 시작하기 전에는 잘못된 지식을 올리면 어떡하지, 별거 없는데 포스팅 갯수 채우려고 올리면 어떡하지 하는 고민이 많았다. 하지만 글을 올릴수록 잘못된 정보를 올렸으면 고치면 되지, 내가 배운 거니까 별거인지 아닌지 따질 필요가 있나 정리 잘해놓으면 미래의 나에게 도움이 되면 됐지 해가되지 않을거라는 생각이 들었다. 개발을 진행하면서 오류가 생겨도 좌절하는게 아니라 오류 해결하고 블로그에 포스팅을 올리고 만다!하는 오기도 생긴다. 행복한 백수생활운전면허증 2종 취득 퇴사하고나서 바로 이직을 준비하지는 않았다. 이전 회사에서는 연차도 쉽게 쓰지 못했기 때문에 쉬는 김에 벼르던 운전면허증을 취득했다. 후후 2종 보통 한번에 필기 - 실기 - 주행까지 한번에 내가해냄😎😎제주도 여행 그리고 리프레시를 위해 제주도로 갔다. 제주도에서 처음 본 브로콜리 모양의 나무 고소하고 약간은 느끼한 냄새가 났다. 홍콩분이 운영하시는 서귀포의 홍콩 밀크티 카페 너무 맛있어서 서귀포에 있는동안 자주 갔다. 밀크티는 캔포장도 돼서 사왔고 다정이네에서 진미채 김밥을 사먹었다. 진짜 맛있었다. 청귤차가 굉장히 마음에 들어서 청귤철에 청귤사서 청을 담가보기로 함 운전면허증을 취득한지 얼마 안돼서 스쿠터밖에 못빌렸다. 그래도 스쿠터를 타서 더 재미있었던 우도 여행동네 개발자 친구들과 추억 만들기 근처에 모각코하고 운동을 같이할 친구들이 있다는것은 참 감사한 일이다. 개발자인 친구들끼리 업무의 고충을 듣고 조언하는 시간은 언제나 보람찼다.개발과 관련되지않은 개인적인 고민도 말하고 다음엔 어디 놀러갈지 정하는 시간은 언제나 즐거웠다. 사진찍지는 않았지만 같이 모각코하고, 저녁을 먹고, 트레킹을하고 수영도 다녀왔다. 이번 여름이 가기전에 같이 스쿠버 다이빙을 다녀올 계획을 세웠다. 모두 시간이 될때 히말라야 트레킹도 도전할 생각이다.😍😍😍생일파티 소중한 친구가 감사하게도 룸을 빌려서 생일파티를 해줬다.나름 꾸준했던 외국어 공부말해보카 매일 75단어씩 공부하기를 목표로 진행했다 개발자에게 가장 중요한 언어는 영어라는 말을 들었다. 현재 거의 모든 컴퓨터 언어는 공식사이트에 그 언어를 사용하기 위한 가이드를 올린다. 그것도 영어로. 물론 한국어로 번역해주는 멋진 곳도 있지만 영어판보다 설명이 생략되어 있거나(MDN...) 아예 한국어로 번역된 설명이 없기도하다(역시 MDN). 또 한국어로 검색할 때보다 영어로 검색할때 stackoverflow의 도움을 많이 받았다. 영어를 공부해야한다는 조언을 듣고 영어로된 공식문서를 자주 확인하다보니 영어공부를 안할 수가 없었다. 영어로 검색하는 습관을 들이고 영어에 더 친숙해지고자 개발자 친구들과 말해보카 프리미엄을 구매하고 공부중이다! 확실히 매일 영어공부를 하다보니 영어에 친숙해지고 영어로 검색하는데 두려움이 줄어드는 듯 하다. 그 친구들과 주말 아침에 함께 정한 주제로 영어 스피킹을 진행한지 한달정도 되는데 스피킹 실력이 느는줄은 모르겠지만 거부감은 갈수록 덜해지는 듯 하다. 주말 영어 스피킹 모임에 꾸준히 참석하는걸 이번달 목표로 정한다. 듀오링고 스페인어 꼭 어디 기록하면 이렇게 한번씩 빼먹는다 아쉬운 내 streak 인생의 숙원사업 스페인어로 대화할만큼, 기사를 읽을 수 있을만큼 스페인어 수준을 올리기 🙄 음... 작년과 올해 초에 DELE B1 시험을 볼까 생각했고 문제집도 샀지만 업무강도가... 업무를 때려치고 DELE 공부를 할 순 없으니 미뤄뒀다. 듀오링고라도 열심히 하기로 했는데 솔직히 말하면 듀오링고도 열심히 안했다.🙄🙄 지금은 이직 준비로도 벅차서 못하고 내년에 일정나오고 업무에 지장이 없다면 내년 5월 시험에 도전해볼 생각이다.7월의 회고와 8월달 다짐 아쉽게도 취업준비중이라 원하는 만큼 공부하지는 못했다. 강의하나 듣고 이력서 작성하고 지원하고 이력서 수정하고 지원하기를 반복해서 생각했던 공부만 맘껏할수있는 상황이 아니었다. 개발자 친구들과 열품타 그룹에 들어가 공부시간을 기록하고 있는데 최근 공부시간 기록이 처참하다... 😥 분발해야겠다. 진행중이라 자세히 적을 순 없지만 감사하게도 다음 프로세스를 위해 연락이 온 회사들과 채용 프로세스를 순조롭게 진행하는것이 8월의 목표다. 8월에는 방통대 개강도 있기때문에 더 바빠질 예정이다. 얼른 자리 잡아야되겠다는 생각이 든다.😂😂 퇴사하고 충분히 쉬어서 이제는 일하고 싶어서 좀이 쑤신다. 프로젝트에 투입되고 업무하면서 오류도 내고 머리싸매고 배우고 동료 개발자 분들에게 질문을 하며 지식을 쏙쏙 빼먹고싶다. 8월의 나도 힘내길 응원한다.💪💪 " }, { "title": "[Recoil] atom, selector", "url": "/posts/recoil_atom_selector/", "categories": "Recoil", "tags": "Recoil, selector, atom, React", "date": "2022-07-29 21:10:00 +0900", "snippet": " Recoil 공식 문서 Recoil은 React를 위한 state 관리 라이브러리이다. React에서 state는 컴포넌트의 상태고 컴포넌트의 상태가 변경될 때마다 React는 화면을 리랜더링해서 바뀐 정보를 노출시킨다.문제는 React의 기본 state만 사용하면 전역으로 사용하는 상태를 관리가 힘들다는 것이다. 여러 화면에서 공통으로 state에 접근하기 위해서는 컴포넌트 줄줄이 state를 물려줘야한다. 그렇게하면 코드도 또 줄줄이 길어지고 state를 사용하지 않은 페이지에도 state를 물려주게 되어 쓸데없는 코드가 늘어난다. 그리고 이때 등장하는게 Recoil이다. Recoil은 state가 이리저리 돌아다니는 현상을 막아준다. Recoil은 React 의 state를 atom으로 관리한다. atom을 사용하면 state가 사용되지 않는 컴포넌트를 타고 돌아다니는게 아니라 state정보가 필요한 컴포넌트가 atom에 직접 연결해서 바로 정보를 얻을 수 있다.Recoil atom에 대한 youtube 영상 npm install recoil Recoil을 설치한다.AtomApp.tsximport React from \"react\";import { RecoilRoot } from \"recoil\";import ReactDOM from \"react-dom\";import App from \"./App\";ReactDOM.render( &lt;React.StrictMode&gt; &lt;RecoilRoot&gt; &lt;App /&gt; &lt;/RecoilRoot&gt; &lt;/React.StrictMode&gt;, document.getElementById(\"root\")); Recoil을 사용하기 위해 RecoilRoot를 import하고 App을 감싼다.atom.tsxexport interface IToDo { text: string; id: number; category: Categories;}export const categoryState = atom&lt;Categories&gt;({ key: \"category\", default: Categories.TO_DO,});export const toDoState = atom&lt;IToDo[]&gt;({ key: \"toDo\", default: [],}); atom을 관리하기 위한 atom.tsx를 만들고 사용할 atom과 selector를 작성한다. atom.tsx 외부에서도 사용할거니까 export 하는건 필수ToDo.tsximport { useSetRecoilState } from 'recoil';function ToDo({ text, id, category }: IToDo) { const setToDos = useSetRecoilState(toDoState); const onClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; { ... setToDos((oldToDos) =&gt; { ... }); }; return ( ... &lt;button name={Categories.TO_DO} onClick={onClick}&gt; TO_DO &lt;/button&gt; ... );} atom.tsx에 있는 toDoState를 사용하기 위해서는 useSetRecoilState를 import한다. 참고로 Recoil atom은 React state와 유사하게 변수와 그 변수를 수정하는 함수 세트를 가지고 있다. useRecoilValue는 atom의 상태를 받아오는 함수고 useSetRecoilState는 atom 상태를 변경하기 위한 함수다. 두 기능을 모두 사용하고 싶다면 useRecoilState. useRecoilState 는 useState처럼 atom과 atom을 수정하는 함수를 함께 사용할수 있다. ToDo.tsx에서는 setToDos를 사용해서 onClick하면 onClick 함수에서 todo 상태를 변경하는 로직을 작성한다.Selector selector는 atom 혹은 다른 selector의 상태를 입력받아서 동적인 데이터를 반환하는 함수다. 쉽게 말하면 atom, selector의 state 를 받아와서 원하는대로 가공하고 가공된 state를 반환하는 함수다.atom.tsxexport interface IToDo { text: string; id: number; category: Categories;}export const toDoState = atom&lt;IToDo[]&gt;({ key: \"toDo\", default: [],});export const categoryState = atom&lt;Categories&gt;({ key: \"category\", default: Categories.TO_DO,});export const toDoSelector = selector({ key: \"toDoSelector\", get: ({ get }) =&gt; { const toDos = get(toDoState); const category = get(categoryState); return toDos.filter((toDo) =&gt; toDo.category === category); },}); toDoSelector는 toDoState와 categoryState 두 atom의 값을 가져오고 원하는 대로 가공해서 화면에 가공된 atom값을 보여준다.import React from \"react\";import { useRecoilState, useRecoilValue } from \"recoil\";import { Categories, categoryState, toDoSelector, toDoState } from \"../atom\";import CreateToDo from \"./CreateToDo\";import ToDo from \"./ToDo\";function ToDoList() { const toDos = useRecoilValue(toDoSelector); const [category, setCategory] = useRecoilState(categoryState); const onInput = (event: React.FormEvent&lt;HTMLSelectElement&gt;) =&gt; { setCategory(event.currentTarget.value as any); }; return ( &lt;div&gt; &lt;h1&gt;To Dos&lt;/h1&gt; &lt;select value={category} onInput={onInput}&gt; &lt;option value={Categories.TO_DO}&gt;TO_DO&lt;/option&gt; &lt;option value={Categories.DOING}&gt;DOING&lt;/option&gt; &lt;option value={Categories.DONE}&gt;DONE&lt;/option&gt; &lt;/select&gt; &lt;CreateToDo /&gt; {toDos?.map((toDo) =&gt; ( &lt;ToDo key={toDo.id} {...toDo} /&gt; ))} &lt;/div&gt; );} selector역시 atom을 사용하는 것과 마찬가지로 useRecoilState, useRecoilValue, useSetRecoilState 함수를 사용해 atom값을 가져오거나, 수정할 수 있다.🎈참고할만한 블로그 [Recoil] 전역 상태관리 라이브러리 - Recoil 정복기" }, { "title": "[MM] TED talk : The power of vulnerability | Brené Brown, JSconf, indentation rules in HTML ", "url": "/posts/ted0727/", "categories": "TED", "tags": "TED, vulnerability, HTML, JSconf", "date": "2022-07-27 05:44:00 +0900", "snippet": " 미라클 모닝할때 듣는 Ted talk를 흘려보내기보다는 기록하는게 좋을 것 같아서 기록해본다. 기록할만한 게 있으면 앞으로도 종종 써야지 미라클 모닝글은 앞머리 MM로 정하고 쓰기로함 자신의 가치에 대한 믿음이 있는 사람들은 자신의 취약성을 받아들이는 경향이 있었다. 그들은 자신의 가치를 믿고 전력으로 다른 사람들과의 관계를 이어갔고, 자신의 일에 전념했고, 자기 자신과 타인에게 친절했다. 그리고 그 이유는 자신의 취약성을 완전히 받아들이는 것이었다. 아픔과 고통을 없애기 위해 특정 감정만을 억누르는 것은 불가능하다.그래서 이런 감정을 억누르면 행복, 즐거움 까지 느끼지 못하게 된다. 자신의 취약성을 받아들이지 못하고 감정을 억누르는것은 위험한 악순환의 시작이 된다. 불확실함, 불완전함, 취약성을 억누르고 완전함, 확실함 만을 추구하면 대화가 없는 비난만 존재한다. 따라서 자신, 타인과의 원만한 관계를 위해서는 자신의 취약함을 인지하고 받아들여야한다. 그나저나 JSconf는 왜 티켓구매 시간이랑 링크를 메인 화면에 안거는지...? 궁금합니다... JSconf Korea 공식 사이트 위에 작성한 요약문 첫문장에 들여쓰기를 적용하려다가 찾은사이트 Indentation and Spacing in HTML 내가 원하는 해결책은 아니었지만 HTML 작성 규칙을 알려줘서 저장함. 전체 목록 훑어봐도 좋을 듯하다. p tag 들여쓰기는 text-intent 속성 임베디드 된 유투브 영상 사이즈를 화면 비율에 맞게 변화하게 만들고 싶어서 참고한 stackoverflow 글 " }, { "title": "[React] React-hook-form", "url": "/posts/react_hook_form/", "categories": "CSS", "tags": "React, React JS, JS, Javascript, React-hook-form", "date": "2022-07-24 15:00:00 +0900", "snippet": " React Hook Form 공식 문서 메인 화면에 써 있다 시피 (Performant, flexible and extensible forms with easy-to-use validation.) html form 태그를 쉽고 유연하게 사용하도록 도와주는 React hook이다. 그중 가장 기능이 많고 이번 프로젝트에 많이 사용한건useForm useForm은 register, watch, handleSubmit, setValue, getValue등의 함수를 제공한다.register, handleSubmit 함수 사용 예시 input 입력창, select 요소 을 이용해 등록할 떄 사용하는 함수 handleSubmit 함수는 form validation이 완료되면 다른 함수를 parameter로 받아서 form data를 받을 수 있다. onValid로 받은 form 데이터는 객체로 리턴된다. html에서 required 속성을 추가해서 form validation할 수 있지만 웹 개발자도구 화면에서 required를 지울 수 있다. javascript로 form에 validation을 추가하면 속성을 지울수 없다는게 장점이다.function ToDoList() { const { register, watch, handleSubmit } = useForm(); const onValid = (data: any) =&gt; { console.log(data); }; return ( &lt;div&gt; &lt;form onSubmit={handleSubmit(onValid)}&gt; &lt;input {...register(\"Email\"), { required: true }} placeholder=\"Email\" /&gt; &lt;input {...register(\"lastName\")} placeholder=\"lastName\" /&gt; &lt;input {...register(\"firstName\")} placeholder=\"firstName\" /&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );}공식사이트에 올라온 register 함수의 사용법 예시 onChange, onBlur 등의 기능을 사용할 수 있다.const { onChange, onBlur, name, ref } = register('firstName');// include type check against field path with the name you have supplied.&lt;input onChange={onChange} // assign onChange event onBlur={onBlur} // assign onBlur event name={name} // assign name prop ref={ref} // assign ref prop/&gt;// same as above&lt;input {...register('firstName')} /&gt;formState 사용 예시 전체 form state에 대한 정보를 갖고있는 객체. 사용자와 form의 interaction을 확인할 수 있다. fromState의 errors는 form의 required, pattern에 맞지 않는input이 제출됐을 경우 오류가 뜬 input box와 error message를 함께 보여주는 객체다.function ToDoList() { const { register, handleSubmit, formState: { errors }, } = useForm(); const onValid = (data: any) =&gt; { console.log(data); }; console.log(errors); return ( &lt;div&gt; &lt;form style={{ display: \"flex\", flexDirection: \"column\" }} onSubmit={handleSubmit(onValid)} &gt; &lt;input {...register(\"email\", { required: \"Email is required\", pattern: { value: /^[A-Za-z0-9._%+-]+@naver\\.com$/, message: \"only naver id can be enrolled\", }, })} placeholder=\"Email\" /&gt; &lt;span&gt;{errors?.email?.message}&lt;/span&gt; &lt;input {...register(\"lastName\", { required: true })} placeholder=\"lastName\" /&gt; &lt;span&gt;{errors?.lastName?.message}&lt;/span&gt; &lt;input {...register(\"firstName\", { required: true })} placeholder=\"firstName\" /&gt; &lt;input {...register(\"password\", { required: \"Your password is required\", maxLength: { value: 10, message: \"Your password is too short\", }, })} placeholder=\"Password\" /&gt; &lt;span&gt;{errors?.password?.message}&lt;/span&gt; &lt;input {...register(\"password1\", { required: \"password is required\", minLength: { value: 5, message: \"your password need more than 5 letters\", }, })} placeholder=\"Password1\" /&gt; &lt;span&gt;{errors?.password1?.message}&lt;/span&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );}" }, { "title": "[CSS] box model, box sizing, display", "url": "/posts/css101_part1/", "categories": "CSS", "tags": "CSS, box model, box sizing, display, block, inline, inline block", "date": "2022-07-24 15:00:00 +0900", "snippet": "\t기본 ! : MDN CSS 공식 문서 참고할것 box model content , padding, border, margin으로 이루어져있다. content : width(가로), height(세로) padding : content 와 border 사이의 공간을 나타낸다. border : 테두리. 굵기, 스타일, 색상 세 property를 명시해야함 border : 1px solid #000; 혹은 테두리를 없앨 때 border : none; border-radius : 50% border-top-left-radius : 10px; outline : border와 유사해보이지만 box 내부에서 영역을 차지하지 않고 border 영역 밖에 있는 라인이다. button, input, textarea 가 focus 혹은 active 될때 주로 보인다. 원하지 않을때에는 outline: none; 을 설정한다. button:active,button:focus,input:active,input:focus,textarea:active,textarea:focus { outline: none;} margin : 요소와 요소 사이의 간격을 나타낸다. 개발자 도구 &gt; Elements&gt; computed 에서 확인 가능 shorthand style : top - right - bottom - left top &amp; bottom, right &amp; left는 세트라고 생각하면 된다. margin top &amp; bottom : 20px, right &amp; left: 40px -&gt; margin: 20px 40px box sizing box sizing : border-box; margin, padding으로 따로 설정된 사이즈를 포함 실제 화면에 노출되는 사이즈를 component width, height으로 한계를 지어준다. content-box : default value가 content-box 로 설정되어있다. component width, height에 margin, padding값을 더해 화면에 보여준다. css를 구현할 때 전체 선택자로 border-box 설정을 해주기도 한다.* { box-sizing: border-box; margin: 0;}//margin 을 0으로 설정하면 각기 다른 요소들의 default margin을 고려하지 않아도 되서 편하다.display box type을 결정짓는 css, display 값이 어떤것이냐에 따라 box type이 달라진다.block 같은 행에 다른 component가 못 들어오게 막는다. 따로 width를 선언하지 않은 경우 width = 부모 contentbox의 width. width를 선언하고 그 길이가 부모 contentbox의 width보다 작다면 남은 공간은 margin으로 채운다. margin : 0 auto;를하면 가운데 정렬되는 이유가 이것이다. margin-left :auto, margin-right:auto 로 빈 공간을 왼쪽 오른쪽 반반씩 나누기 때문에 content가 가운데로 정렬된다. child의 height을 설정하고 parent의 height을 따로 설정하지 않는다면 child height의 총합 = parent의 heightinline 같은 행에 다른 component가 들어오도록 한다. 행에 공간이 부족하다면 다음 행에서 보여준다. span, a, strong 기본 display가 inline이다. width, heigth, padding(top &amp; bottom), border(top &amp; bottom), margin(to &amp; bottom) 사용 불가. 영역으로 취급을 안해주고 덮어씌우는 것과 같은 모양을 보여줌. inline의 구현 목적에 어긋나기 때문에 사용하지 않는 것을 추천함 padding, border, margin이 적용되지 않는다 싶으면 꼭 display가 inline인지 확인하기!! img tag는 inline이지만 display를 바꾸지 않아도 예외적으로 사이즈를 변형할 수 있다. css display inline 참조 display : block;을 적어서 display 상태를 명시해주는 것이 좋다.&lt;/strong&gt;inline block block의 장점과 inline의 장점의 결합이라고 볼 수 있다. 행으로 배치되지만 개별 영역을 존중(?)하는 display 모든 속성 사용가능 💡 display:none; 인 요소는 display : block;으로 화면에 노출시킬 수 있다." }, { "title": "[HTML] HTML section, article, nav, aside, main ", "url": "/posts/html101_part5/", "categories": "HTML", "tags": "HTML, section, article, nav, aside, main", "date": "2022-07-22 12:00:00 +0900", "snippet": "\t기본 ! : mdn html elements 공식 문서 참고할것 section, article, nav, aside sectioning element 내에는 반드시 heading 태그를 작성해야한다. heading 태그는 section은 내부의 콘텐츠를 설명하는 역할을 한다. heading tag는 모든 사용자 특히 screenreader를 사용하는 사용자에게 유용하고 SEO를 위해서도 좋다.section heading tag와 관련된 MDN 문서 article : 기사, 블로그 등 콘텐츠로서 완결성이 있는 경우 사용. 혼자 독립적으로 구분해서 배포하거나 재사용할 수 있는 구획을 나타낸다. aside : sidebar나 call-out box로 자주 사용된다. 본 콘텐츠와 간접적인 연관성이 있을 때 사용한다. &lt;section&gt; &lt;h1&gt;섹션의 제목&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;nav&gt; &lt;h1&gt;메뉴&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; main 전체 화면에서 메인파트를 의미하며 그렇기 때문에 main 태그는 한 화면에 하나만 노출되어야한다. 전달하고자하는 메세지와 직접적으로 연관되어있으며 앱의 중심이되는 기능을 담당한다. " }, { "title": "[추천] 주니어 개발자를 위한 소소한 개발 외 사이트와 VSCode Extension 정리", "url": "/posts/tools_and_sites_to_recommend/", "categories": "recommendation", "tags": "recommendation, vscode, extensions, git, commit message, markdown, 주니어 개발자", "date": "2022-07-20 16:00:00 +0900", "snippet": " 제가 부족함을 느껴 공부하던중 찾은 정보들입니다. 저도 애용하는 사이트들 입니다. 주변의 도움 받지 못한 주니어 개발자분에게 도움이 됐으면 합니다. 저보다는 덜 헤매고 더 쉽게 공부하시길 바랍니다. 좋은 깃 커밋 메시지를 위한 영어사전 좋은 깃 커밋 메시지 목록이 나열되어있는 블로그 깃 커밋 메시지 규칙이 생소하거나 영어로 커밋 메시지를 작성하는데 어려움을 겪는 사람들을 위해 작성되어 있다. 예시가 존재해서 커밋 메세지를 작성해본 경험이 적은 개발자들에게도 도움이 될 것 같다. 영어에 익숙하다면 How to Write a Git Commit Message blog 마크다운 작성법 velog 마크다운 작성법 마크다운 작성법이 생소한 개발자를 위한 블로그글 예시와 설명이 붙어있어 이해하기 쉽습니다. 이글을 따라 작성하면 당신도 마크다운 천재가 될 수 있다.💪 저는 VsCode 또는 Notepad ++ 에 주로 작성하지만 웹에 마크다운을 작성하면서 확인하기에는 StackEdit가 좋습니다. 스웨거 문서 작성사이트 SwaggerEditor 스웨거 허브 가입, 계정 생성 과정이 복잡하고 귀찮다면 swagger editor로 바로 들어가세요. File &gt; Import file 하시면 파일을 열 수 있습니다. 작성 완료된 파일은 File &gt; SAVE as YAML 로 저장할 수 있습니다. 일단 문서를 보시면 어떤걸 입력해야하는지 감이 오실텐데요. 헷갈리신다면 Swagger API 명세 만드는 법중반부 부터 보시길 추천합니다. 그래도 이해가 안되시면 ‘스웨거 문서 작성법’,’스웨거 api 문서’로 구글링 추천드려요. CanIUse.com CanIUse.com 브라우저별 확장자, CSS 적용 여부를 확인할수 있는 사이트 입니다. 브라우저별로 지원하는 파일 확장자, CSS 속성등이 다르기 때문에 확인이 필요합니다. 검색시 빨간 박스가 뜬다면 그 버전의 브라우저에는 지원하지 않는 속성이라는 뜻이니 추가 설정이 필요합니다. FontAwesome FontAwesome 무료로 사용할수 있는 아이콘들이 있습니다. 일부는 유료지만 무료로도 충분할거예요. FontAwesome Doc FontAwesome을 적용하기위해 읽어야할 문서입니다. VSCode Extension 드림코딩 VSCode Extension 10개 추천을 추천드립니다. 드림코딩 강의를 자주 듣는 편인데 강의도 좋으니 유투브 영상보고 관심 있으시면 드림코딩 강의사이트를 추천드립니다. Javascript 관련된 강의가 많습니다. (저에게는 일절 혜택 없습니다.) Developer Affirmations : VSCode를 열때 마다 영어로된 짧은 응원문장을 하단 우측 창에 띄워 줍니다. 도움을 받기 힘든 주니어 개발자들에게는 작은 응원도 도움이 되더라고요. 짧은 문장을 읽으면서 힘든시간 잘 버티시길 바랍니다. 화이팅! " }, { "title": "[리팩터링] chapter 10 조건부 로직 간소화", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-10/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-07-20 13:24:00 +0900", "snippet": " p.354 조건문 분해하기 거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름과 함수 호출로 바꿔주자. 그러면 전체의 의도가 더 확실히 드러난다. 조건문이 보이면 나는 조건식과 각 조건절에 이 작업을 해주길 좋아한다. 이렇게되면 해당 조건이 무엇인지 강조하고, 그래서 무엇을 분기하였는지가 명확해진다. 분기한 이유 역시 더 명확해진다.기존의 코드if (!aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd)) { charge = quantity * plan.summerRate;} else { charge = quantity * plan.regularRate + plan.regularCharge;}수정된 코드charge = summer() ? summerCharge() : regularCharge();function summer() { return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);}function summerCharge() { return quantity * plan.summerRate;}function regularCharge() { return quantity * plan.regularRate + plan.regularCharge;} p.357 조건식 통합하기 비교화는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있는데, 어차피 같은 일을 할거라면 조건 검사도 하나로 통합하는 것이 낫다.기존의 코드if (appleCnt &lt; 2) return 0;if (bananaCnt &gt; 3) return 0;if (watermelonCnt &gt; 10) return 0;수정된 코드if (fruitCnt()) return 0;function fruitCnt() { return appleCnt &lt; 2 || bananaCnt &gt; 3 || watermelonCnt &gt; 10;} 조건부 코드를 통합하는게 중요한 이유는 두가지다. 첫째, 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다. 나눠서 순서대로 비교해도 결과는 같지만, 읽는 사람은 독립된 검사들이 우연히 함께 나열된 것으로 오해할 수 있다. 두번째 이유는 이 작업이 함수 추출하기 까지 이러질 가능성이 높기 떄문이다. 복잡한 조건식을 함수로 추출하면 코드의 의도가 훨씬 분명하게 드러나는 경우가 많다. p.360 중첩조건문을 보호구문으로 바꾸기 조건문은 주로 두가지 형태로 쓰인다. 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태와 한쪽만 정상인 형태다.두 형태 모두 의도하는 바가 서로 다르므로 그 의도가 코드에 드러나야 한다. 나는 두 경로 모두 정상동작이라면 if와 else 절을 사용한다. 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다. 두번쩨 검사 형태를 흔히 보호구문 이라고 한다.… 보호구문은 ‘이건 함수의 핵심이 아니다. 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다’라고 이야기한다.… 반환점이 하나여야한다는 규칙은 유용하지 않다. 코드에서는 명확함이 핵심이다. 반환점이 하나일 떄 함수의 로직이 더 명확하다면 그렇게 하자.그렇지 않다면 하지 말자.기존 코드function getPayAmount() { let result; if (isDead) result = deadAmount(); else { if (isSeparted) result = separatedAmount(); else { if (isRetired) result = retiredAmount(); else result = normalPayAmount(); } } return result;}수정된 코드function getPayAmount() { if (isDead) return deadAmount(); if (isSeparated) return separatedAmount(); if (isRetired) return retiredAmount(); return normalPayAmount();} 10.310.4 p.404 어서션 추가하기 특정 조건이 참 일때만 제대로 동작하는 코드가 있을 때 어서션을 사용할 수 있다.어서션은 항상 참이라고 가정하는 조건부 문장으로 어서션이 실패했다는건 프로그래머가 잘 못했다는 뜻이다. 어서션의 실패는 시스템의 다른 부분에서는 절대 검사하지 않아야하며, 어서션이 있고 없고가 프로그램 기능의 정상 동작에 아무런 영향을 주지 않도록 작성되어야 한다. 어서션은 프로그램이 어떤 상태임을 가정한 채 실행되는 지를 다른 개발자에게 알려주는 도구이기도 하다. 디버깅하기 편하고 이런 소통 수단으로서의 가치도 있어서, 추적하던 버그를 잡은 후에도 코드에 남겨두곤 한다.테스트 코드가 있다면 어서션의 디버깅 용도로서의 효용은 줄어든다. 단위 테스트를 꾸준히 추가하여 사각을 좁히면 어서션보다 나을 떄가 많다. 하지만 소통면에서 어서션도 매력적임기존 코드//이 코드에는 할인율이 항상 양수라는 가정이 깔려있다.//할인율이 양수임을 확인하는 어서션을 추가해본다.class Customer { ... applyDiscount(aNumber) { return this.discountRate ? aNumber - this.discountRate * aNumber : aNumber; }}수정된 코드class Customer { ... //discountRate 세터를 추가해서 discountRate를 받아올 때 양수임을 확인한다. set discountRate(aNumber){ assert(null === aNumber || aNumber &gt;=0); this._discountRate = aNumber; } applyDiscount(aNumber) { if (!this.discountRate) return aNumber; else { return aNumber - this.discountRate * aNumber; } }} p.407 제어 플래그를 탈출문으로 바꾸기 제어플래그란 코드의 동작을 변경하는데 사용되는 변수를 말하며, 어딘가에서 값을 계산해 제어 플래그에 설정한 후 다른 어딘가의 조건문에 검사하는 형태로 쓰인다.기존 코드for(cont p of people){ if(!found){ if(p === 'Vador'){ sendAlert(); found = true; } }}수정된 코드for(cont p of people){ if(p === 'Vador'){ sendAlert(); break; }}" }, { "title": "[HTML] HTML 101 img, aria-label", "url": "/posts/html101_part4/", "categories": "HTML", "tags": "HTML, img, aria-label", "date": "2022-07-19 15:18:00 +0900", "snippet": "\t기본 ! : mdn html elements 공식 문서 참고할것 img alt 속성은 default로 작성해야한다.필수는 아니지만 접근성에 매우 유용하다. 뭐라고 작성해야할지 모를 때, 이미지가 콘텐츠의 중요한 요소가 아닐 때는 빈칸으로 작성하면 된다. &lt;pre&gt; 이렇게 작성하면 이미지가 화면에 뜨지 않을 때 이미지를 엑스박스로 노출하는게아니라 이미지가 화면에 보이지 않는다. &lt;/pre&gt;&lt;img src=\"hello.png\" alt=\"\" /&gt; aria-label img alt를 작성한 것과 같이 사용자의 접근성을 위해 필요한 속성 대상에 접근가능한 정확한 설명이 없을 떄,DOM에 접근가능한 정보가 없을 때 사용된다. 과도하게 사용하지 말것. aria-labelledby 도 같은 역할을 하는데 aria-labelledby 와 aria-label이 둘다 적용되어있다면 aria-labelledby이 우선시된다. 시각적으로 화면을 확인할 수 없는 사용자가 screen reader를 사용할 때 필요한 정보를 제공한다. 시각적인 정보를 대신해 해당 콘텐츠에 관한 설명을 읽어준다. screen reader 사용자들만을 위해 (aria-label을 사용해) 설명을 하기보다는 모든 사용자를 위해 설명을 작성하고 가능하다면(따로 설명이 필요하지 않게) UI를 더 직관적이게 개발하라. aria-label 관련 MDN 공식문서 예시 : pagination에 적용한 aria-label, 각 anchor에 관한 정보를 제공한다. &lt;div class=\"pagination\"&gt; &lt;a href=\"#\" aria-label=\"Go to previous page\" class=\"disabled\"&gt;Previous&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"#\" aria-label=\"Current page.Go to page 1\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" aria-label=\"Go to page 2\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" aria-label=\"Go to page 3\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;...&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" aria-label=\"Go to page 7\"&gt;7&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;a href=\"#\" aria-label=\"Go to Next page\"&gt;Next&lt;/a&gt;&lt;/div&gt; aria-hidden =”true” : 아이콘이나 이미지와 같이 완전 장식적인 요소라서 설명이 불필요한 경우, 반복된 콘텐츠 &lt;strong aria-label=\"평점 9.4\" class=\"product-card-review\"&gt; &lt;span aria-hidden=\"true\"&gt; &lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i &gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i&gt; &lt;i class=\"fas fa-star-half\"&gt;&lt;/i&gt; &lt;/span&gt; 9.4&lt;/strong&gt; " }, { "title": "[HTML] HTML 101 DOCTYPE, title, link, meta", "url": "/posts/html101_part3/", "categories": "HTML", "tags": "HTML, title, link, meta", "date": "2022-07-18 05:18:00 +0900", "snippet": "\t기본 ! : mdn html elements 공식 문서 참고할것 html파일 기본 뼈대 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; DOCTYPE : DTD 최신의 HTML5버전으로 작성된 문서임을 선언한다. 브라우저는 quirks mode인지 standards mode인지 확인하기 위해 html 파일의 맨 위에 작성된 DOCTYPE을 사용한다.html 파일이 완전한 standards mode임을 명확하게 알려주기 위해 &lt;!DOCTYPE html&gt;을 써줘야함. quirks mode 와 standards mode : Quirks_Mode_and_Standards_Mode mdn 공식문서quirks mode 는 Navigator 4 와 IE 5브라우저에서 표준적이지 않은 layout을 생성한다. DOCTYPE이 명시된 완전한 standards mode에서는 (아마도 ?!) HTML과 CSS 사양에 맞는 웹페이지가 표시된다. head 내부에는 웹 문서에 대한 메타 데이터, body 내부에는 웹 문서에 들어갈 내용 쉽게 말하면 화면에 보여지는 모든 콘텐츠를 보여주는 부분이 body, 웹 문서에 대한 중요한 정보는 head에 작성한다. title, link title : SEO 에 가장 중요한 역할 link : CSS 스타일 시트를 첨부하는 태그 link MDN 공식 문서 rel : relationship 의 준말 css 파일이라면 stylesheet, 아이콘이라면 icon media : media type을 작성한다. media condition이 참일때만 로드된다. &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"\" href=\"./style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; meta viewport : 화면의 사이즈 viewport mdn 공식문서 예시 : layout이 최소 넓이 500 px를 요구할때의 viewport. 화면이 500 px 이상으로 넓어질 경우 브라우저가 viewport를 넓인다. &lt;meta name=\"viewport\" content=\"width=500, initial-scale=1\" /&gt; name : author : 작성자 명 keywords : 웹 페이지의 키워드 , 검색시 이 키워드들로 검색이 가능하도록 함 description : 콘텐츠에 대한 설명 html meta tag 관련 mdn 공식 문서 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta name=\"author\" content=\"jooheekim\" /&gt; &lt;meta name=\"keywords\" content=\"javascript, html, css\" /&gt; &lt;meta name=\"description\" content=\"\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; " }, { "title": "[HTML] HTML 101 table, audio, video, iframe, abbr, pre, code", "url": "/posts/html101_part2/", "categories": "HTML", "tags": "HTML, table, audio, video, iframe, abbr, pre, code", "date": "2022-07-17 12:22:00 +0900", "snippet": "\t기본 ! : mdn html elements 공식 문서 참고할것 table : tr로 열을 만들고 내부 정보는 th, td 로 입력함 \t //세로 입력방식 &lt;table&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;\t\t\t\t //가로 입력방식\t //thead로 th의 역할을 명시할 수 있다. //tbody로 td th에 관련된 데이터라는것을 명시할 수 있다.\t &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;\t\t &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;\t &lt;/table&gt;\t\t\t rowspan, colspan을 사용해서 테이블 모양을 변경할 수 있음 th 가 가로의 header인지, 세로의 header인지 구분하기 위해 scrope 속성을 추가할 수 있다. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=\"col\"&gt;&lt;/th&gt; &lt;th scope=\"col\"&gt;&lt;/th&gt; &lt;th scope=\"col\"&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th scrope=\"row\"&gt;&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scrope=\"row\"&gt;&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;\t &lt;/table&gt;\t audio controls 속성을 추가하면 audio 소리, 재생 등을 통제할 수 있는 control 바를 제공한다. autoplay, loop autoplay 등의 속성을 추가해서 자동재생, 반복 자동재생 속성을 추가할 수 있다. 브라우저에서 지원하는 파일이 제한될 경우를 위해 mp3, ogg 등 다양한 확장자 source를 추가할 수 있다. 브라우저별 지원하는 파일 확장자를 확인하려면 caniuse.com 에서 확장자명을 입력하면 확인가능함. \t\t &lt;audio controls src=\"AudioTest.ogg\" autoplay&gt;&lt;/audio&gt;\t &lt;audio controls&gt; &lt;source src=\"AudioTest.mp3\" type=\"audio/mp3\" /&gt; &lt;source src=\"AudioTest.ogg\" type=\"audio/ogg\" /&gt; &lt;/audio&gt;\t video audio 와 마찬가지로 autoplay, loop autoplay 속성 추가가능 \t &lt;video controls width=\"250\"&gt; &lt;source src=\"/media/cc0-videos/flower.webm\" type=\"video/webm\"&gt; &lt;source src=\"/media/cc0-videos/flower.mp4\" type=\"video/mp4\"&gt; Sorry, your browser doesn't support embedded videos. &lt;/video&gt;\t iframe 다른 웹사이트를 임베드 할 때 사용 \t\t &lt;iframe id=\"inlineFrameExample\" title=\"Inline Frame Example\" width=\"300\" height=\"200\" src=\"https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&amp;layer=mapnik\"&gt; &lt;/iframe&gt;\t\t abbr abbreviation 약자, 약어. 약자에 대한 설명을 추가해서 mouseover 했을 때 설명을 볼 수 있는 기능을 제공한다. You can use CSS to style your HTML. &lt;p&gt;You can use &lt;abbr title=\"Cascading Style Sheets\"&gt;CSS&lt;/abbr&gt; to style your &lt;abbr title=\"HyperText Markup Language\"&gt;HTML&lt;/abbr&gt;.&lt;/p&gt;\t pre performed text element html 파일에 작성된 텍스트 그대로 보여준다. L TE A A C V R A DOU LOU REUSE QUE TU PORTES ET QUI T' ORNE O CI VILISÉ OTE- TU VEUX LA BIEN SI RESPI RER - Apollinaire code 컴퓨터 언어 코드라는 것을 나타낼때 사용한다. &lt;p&gt; The &lt;code&gt;push()&lt;/code&gt; method adds one or more elements to the end of an array and returns the new length of the array. &lt;/p&gt; 제일 복잡한 form 이랑 table은 지난 프로젝트에서 지겹게 해서 다행이다 😊" }, { "title": "[HTML] HTML 101 a, list, dl, quote, form", "url": "/posts/html101_part1/", "categories": "HTML", "tags": "HTML, a, list, dl, quote, form", "date": "2022-07-16 15:44:00 +0900", "snippet": "React 개발을 찍어먹어봤는데 간단한 버튼 모양을 만드는데도 너무 헤매서 이참에 html, css를 공부해야겠다는 생각이 들었다.해외에서 프론트엔드 개발자로 일하시는 분도 html, css 지식의 중요성을 강조하시기도 했고...퍼블리셔라는 직업이 없어서 html, css 틀을 만들줄 알아야한다고하심 😭중요성을 이제라도 깨달아서 공부를 시작한다! 이 강의 끝날 때 쯤엔 내가 혼자 html css다 짜서 클론하나 해봐야지이 블로그 게시물도 html 태그로 작성되기 때문에 html공부를 심도있게 하면 게시물도 좀 더 깔끔하게 보일것같다. \t기본 ! : mdn html elements 공식 문서 참고할것 개발자 도구 &gt; network &gt; JS, CSS, IMG, MEDIA, FONT, DOC 파일 확인가능. html파일은 DOC로 분류된다. 문서 구조와 정보 위계가 명확하게 보이는 HTML코드를 작성하는게 중요하다.( Semantic Markup : 의미 구조에 맞는 html 작성법 ) 다양한 HTML 태그를 사용해서 SEO 검색엔진 최적화에 도움을 주는 것이 중요하다. div만으로 작성하지 말것 tag attribute는 기본 tag가 갖지 못하는 추가적인 속성을 설명해준다. 강조 태그 em, strong a 태그 href 속성 필수 페이지 내 이동 : 이동하길 원하는 id, class 등 선택자와 값을 href 속성값에 작성하면 그 위치로 이동한다. \t &lt;a href=\"#hello\"&gt;&lt;/a&gt;\t\t &lt;section id=\"hello\"&gt; blablabla &lt;/section\t 메일쓰기 : mailto:메일주소 를 href 속성값에 작성하면 메일 입력창으로 이동한다. &lt;a href=\"mailto:helloworld@gmail.com\"&gt; helloworld에게 메일 쓰기 &lt;/a&gt;\t 전화걸기 : tel:전화번호 를 href 속성값에 작성하면 그 번호 대로 전화화면으로 이동한다. &lt;a href=\"tel:0100000000\"&gt; helloworld에게 전화걸기 &lt;/a&gt;\t target=”_blank” : 새로운 탭으로 이동 list ol: ordered list ul : unordered list. style 속성으로 li 의 bullet 을 없애거나 (style=”list-style-type: none) type 속성을 추가해 bullet type을 변경할 수 있으나… deprecated! ul 속성 관련 mdn문서 li : list item 목록의 요소로 ol과 ul 내부에는 li 태그로만 목록을 작성할 수 있다. li 외의 태그(a)를 삽입하고 싶다면 li 태그 내부에 태그(a)를 넣어야한다. 정의 리스트 dl : description list dt : description term 용어, 키 값 dd : description data 용어에 대한 설명 dfn : definition 정의하는 문장내에서 정의하는 용어를 나타낼때 사용한다. dfn mdn 공식문서 &lt;p&gt;A &lt;dfn id=\"def-validator\"&gt;validator&lt;/dfn&gt;is a program that checks for syntax errors in code or documents.&lt;/p&gt; 이런식으로 쓰인다. dl 내부에만 사용되는건 아닌 모양 dl 의 자식요소는 오직 div, dt, dd만 가능함 dt와 dd는 반드시 dl의 자식 요소로 존재해야한다. 인용 blockquote : 내부에 cite 태그로 인용문의 출처를 적어줌, cite 속성을 추가해서 인용 출처가 어디인지 명시할 수 있다. q : 문장 내부에 인용할 때 사용한다. 쌍따옴표가 생긴다. &lt;p&gt;&lt;p/&gt; &lt;p&gt;&lt;p/&gt; &lt;p&gt; &lt;q&gt;lalalalalal&lt;/q&gt; said song &lt;p/&gt; form : 사용자로부터 정보를 입력받을 때 사용 method, action 속성값 필수 input : type 속성에 따라 입력받을 수 있는 정보가 달라진다. 매우 다양한 type이 존재함input type mdn 공식 문서 placeholder, minlength, maxlength, required, disabled, value, min, max, pattern type : radio일때 동일한 name 값을 넣어야 한 그룹으로 취급되어 둘중 하나를 선택할 수 있게 된다. value 값을 다르게 넣어야 form submit 할때 값이 보내진다. \t\t &lt;input type=\"radio\" name=\"subscription\" value=\"subscribed\" id =\"subscribed\"/&gt; &lt;label for=\"subscribed\"/&gt;\t\t\t &lt;input type=\"radio\" name=\"subscription\" value=\"unsubscribed\" id =\"unsubscribed\"/&gt; &lt;label for=\"unsubscribed\"/&gt; type : checkbox 일때 역시 동일한 name값을 넣어서 한 그룹으로 묶는다. 역시 submit시 value값이 보내짐 \t\t &lt;input type=\"checkbox\" name=\"skills\" value=\"html\" id =\"html\"/&gt; &lt;label for=\"html\"/&gt;\t\t\t &lt;input type=\"checkbox\" name=\"skills\" value=\"css\" id =\"css\"/&gt; &lt;label for=\"css\"/&gt; select name, value 필수 multiple 속성을 select에 추가해 여러 option을 선택할 수 있음 \t\t &lt;label for=\"skill\"&gt;스킬&lt;/label&gt; &lt;select multiple name =\"skill\"&gt; &lt;option value=\"html\"&gt;HTML&lt;/option&gt; &lt;option value=\"css\"&gt;CSS&lt;/option&gt; &lt;option value=\"js\"&gt;JS&lt;/option&gt; &lt;/select&gt; textarea : rows, cols 속성으로 가로 세로 길이 지정할 수 있음 button : type button, submit(form 제출용), reset(input value reset)이 있다. label : for 속성 값에 input id값을 넣어줘야함 " }, { "title": "[React] 오류 수정", "url": "/posts/reactjs_error_fix/", "categories": "React", "tags": "React, React JS, JS, Javascript, strictmode", "date": "2022-07-14 12:29:00 +0900", "snippet": " React.StrictMode 설정시 데이터가 두번 불러와지는 현상, 그 이유 React StrictMode 관련 공식 문서 strict mode의 특징 안전하지 않은 생명주기 메서드를 사용하는 모든 클래스 컴포넌트 목록을 정리해 컴포넌트 관련 경고 로그 출력 이전의 React에서 레거시 문자열 ref API를 사용할때 경고 출력 ( ref API 를 대체해 콜백형태 사용 권장 ) 이전에 사용됐지만 현재 권장되지 않는 findDOMNode 사용 경고 권장되지 않는 레거시 contect API 사용 경고 렌더링 단계 생명주기 메서드는 여러번 호출될 수 있기 떄문에 부작용을 포함하지 않는 것이 중요 -&gt; 이중으로 호출해 문제가 되는 부분을 발견하게 도와줌stackoverflow react 두번 랜더링되는 문제 질문과 답변 -&gt; 해결방법은 간단하다 react 버전을 내리거나 strictmode를 주석처리하거나 React.StrictMode 설정시 React-router-dom Link hook이 안 먹는 현상, 그 이유 react-router-dom 버전이 react 18버전과 맞지 않아서 발생했던 문제, react-router-dom을 최신 버전으로 올리거나 react버전을 내리면 해결된다. React ‘react-dom’과 ‘react-dom/client’의 차이 ReactDOMClient 관련 공식 문서 react-dom/client 패키지는 클라이언트가 app을 열때 동작하는 클라이언트를 위한 메서드 대부분의 component에 적용할 필요가 없다. index.tsx 에 ReactDOM.render()가 아니라 ReactDOM.createRoot()를 사용하는 이유가 이거였음 새로나온 react 18부터 적용됨 " }, { "title": "[Typescript] 오류 수정", "url": "/posts/typescript_error_fix/", "categories": "Typescript", "tags": "Typescript, TS, JS, Javascript", "date": "2022-07-08 15:43:00 +0900", "snippet": " No overload matches this call ApexChart를 적용할때 발생한 오류다. 참고한 블로그 간단하게 말하면 overloaded function에서 지정한 매개변수들의 타입 형식(여기서는 [number, number] 또는 [string, string])과 실제 전달한 인자의 타입 형식이 일치하지 않으면 뜨는 에러이다. 따라서 interface를 생성해 IChartAxis[]로 데이터 타입을 지정해준다. \t interface IChartAxis { x: Date; y: number[]; } ...\t\t\t function chart(){\t\t ... return{\t\t\t ...\t { name: 'Price', data: data?.map((props) =&gt; { return { x: new Date(props.time_open * 1000), y: [ parseFloat(props.open), parseFloat(props.high), parseFloat(props.low), parseFloat(props.close), ], }; }) as IChartAxis[], }, ]} ApexChart candlestick 타입 설정 공식문서 " }, { "title": "[React] React typescript", "url": "/posts/ReactJS_typescript/", "categories": "React", "tags": "React, React JS, JS, Javascript, TS, Typescript", "date": "2022-07-07 09:00:00 +0900", "snippet": "npm install --save typescript @types/node @types/react @types/react-dom @types/jest 기존 Create React App 프로젝트에 타입스크립트 설정 추가 React JS 타입스크립트 공식문서 TS 설정을 추가 + 파일 확장자명을 .tsx 후 발생한 오류 경로를 찾지 못하고있다. .tsx 를 붙이면 화면은 제대로 나오지만 import path가 .tsx로 끝날수 없다고 경고창이 뜬다. //@ts-ignore을 App import 위에 붙여서 임시방편으로 오류를 해결함 아무래도 ts 설정이 제대로 되지않은것 같아서 tsconfig.json파일을 추가해줌. 공식문서에는 tsconfig.json파일이 알아서 생성되니까 따로 만들 필요가 없다고 했으나~ 안 만들어지니까 일단 만들어봄 { \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"], \"allowJs\": true, \"skipLibCheck\": true, \"esModuleInterop\": true, \"allowSyntheticDefaultImports\": true, \"strict\": true, \"forceConsistentCasingInFileNames\": true, \"noFallthroughCasesInSwitch\": true, \"module\": \"esnext\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"react-jsx\" }, \"include\": [\"src\"] } 해결 ^^ㅎ…. 참고) 설정파일이 엉켰다는 생각이 들때는 node_modules, package-lock.json파일을 지우고 다시 설치하자. 설정파일 삭제 및 설치 관련 블로그 # 👇️ delete node_modules and package-lock.json rm -rf node_modules rm -f package-lock.json # 👇️ clean npm cache npm cache clean --force npm install JS에서 사용하던 라이브러리나 패키지(A)를 TS에서도 사용하고 싶다면 npm @types/(A) 로 구현되어있는지 확인하고 설치하자. 그래도 없다면 DefinitelyTyped 문서에 있는지 확인해보고 직접 만들어서 DefinitelyTyped에 기여해보기… 언젠간! 널 병합 연산자 (nullish coalescing operator ??) : 왼쪽 value가 null이거나 undefined일때 ?? 오른쪽의 value를 반환한다. const foo = null ?? 'default string'; //'default string' defaulttheme 설정을위해 declaration file을 생성한다.declaration file 설정 관련 공식 문서 DefaultTheme에 원하는 theme 요소와 그에 해당하는 타입을 설정한다. DeafultTheme을 받는 theme.ts파일을 생성하고 각 요소에 해당하는 색상을 설정한다. index.tsx에 ThemeProvider 를 import하고 theme을 설정한다. " }, { "title": "[React] styled-components", "url": "/posts/ReactJS_styled_components/", "categories": "React", "tags": "React, React JS, JS, Javascript", "date": "2022-07-05 13:53:00 +0900", "snippet": "퇴사하기 전에 React 강의를 일단 듣고 따라 치면서 공부했던 기억이 있는데 한동안 취준, 이력서 작성에만 집중하다보니 다 잊어버렸다. 예전 깃 계정으로 코드를 따라쳤던 기억은 있는데 기록을 안해놔서 어떻게 구현했는지 기억이 하나도 안나요… 기록의 중요성을 다시 한번 느낀다. 리액트 강의 재수강하면서 어떻게 포트폴리오에 적용할지 생각해보자. react app 세팅 문서 react 세팅 공식문서styled-components 적용npm i styled-components styled.(HTML component)로 짜여져있기 때문에 component 속성을 바꾸려면 styled뒤의 html component를 바꾼다. 공통된 css 속성은 component로 설정하고 공통되지 않은 css 속성은 개별 props로 받는다. props가 다르기때문에 클래스명이 같지 않은 것을 확인할 수 있다. styled function을 활용해 기존의 속성을 그대로 상속받고 새로운 속성을 추가할 수 있다.(기존 속성에서 props로 받는 데이터가 있다면 props도 잊지않고 추가해야함) component를 변경하고 싶을때는 as=”변경하고싶은 html component명” 을 추가한다. 공통된 component의 속성을 설정할때는 attrs({ 속성 })을 작성한다. 애니메이션을 구현하기 위해서 styled-component에서 keyframes를 추가하고 from - to 또는 0% - 50% - 100%의 단계으로 애니메이션을 적용할 수 있다. 컴포넌트 내부의 html component를 조작하기 화면 테마 적용하기 ThemeProvider import index.tsx에서 App 컴포넌트를 Themeprovider 컴포넌트로 감싸고 lighttheme, darktheme에 테마별 변경요소와 색상을 설정한다. app.tsx 에서 theme별 props를 받아 배경 색상, 글씨 색상에 반영한다. " }, { "title": "[TS] Typescript의 class", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC-3/", "categories": "Typescript", "tags": "TS, Typescript, JS, Javascript", "date": "2022-07-02 18:53:00 +0900", "snippet": " class 생성자 class Player{ constructor( private firstName: string, private lastName : string, public nickName : string ){} } 'use strict' class Player{ constructor(){ this.firstName = firstName, this.lastName = lastName, this.nickName = nickName } } 위의 TS코드가 아래의 JS코드로 작성한 것과 동일함 private인 요소들은 외부에서 접근 불가능함 class 상속 추상 클래스는 인스턴스를 만들 수 없다. 추상 메서드는 구현이 되어있지 않은 코드가 없는 메서드다. 일반 클래스는 추상클래스를 상속받는다. 추상 클래스에 추상 메서드가 있다면 일반 클래스는 추상메서드를 반드시 상속해야한다. 추상메서드에 접근제어자가 private인 속성이 추상 메서드에 작성되어도 일반 클래스는 속성에 접근할 수 없다. Player 클래스에서만 접근하고 외부에서 접근 불가능하기 위해서는 protected 접근제어자를 사용한다. abstract class User{ constructor( protected firstName: string, protected lastName : string, public nickName : string ){} abstract getFullName():void }\t class Player extends User{ getFullName(){ return `${this.firstName} ${this.lastName}` } } const nico = new Player(\"joohee\",\"kim\",\"jj\") nico.getFullName();\t class 를 타입으로 쓰기 type Words = { [x:string]:string } //Words 타입은 string을 프로퍼티로 가지는 객체 //words는 string형의 데이터 여러개가 들어가는 객체 class Dictionary{ private words: Words constructor(){ this.words = {} } add(word:Word){ //클래스를 타입으로 사용할 수 있다. if(this.words[word.term] === undefined){ this.words[word.term] = word.def; } } def(term:string){return this.words[term]} } // constructor 내부에 this.words = {}로 words 객체를 할당해줌\t class Word{ constructor( public term:string, public def :string ){} } const kimchi = new Word(\"kimchi\",\"김치\") const bab = new Word(\"bab\",\"밥\") const dict = new Dictionary() dict.add(kimchi); dict.add(bab); // dict: { \"words\": { \"kimchi\": \"김치\", \"bab\": \"밥\" } } interface type과 같이 객체의 틀을 잡아준다. 다만 type은 데이터와 데이터 형식을, interface는 데이터 형식만 통제한다. type Team = \"red\" | \"blue\" | \"white\" type Height = 160 | 170 | 180\t interface Player { name : string, team : Team, height : Height }\t const song : Player = { name : \"song\", team :\"blue\", height : 160 } type과 인터페이스는 클래스와 마찬가지로 상속을 할 수 있다. //type 상속 type User = { name : string } type Player = User &amp; { } //interface 상속 interface User{ name : string } interface Player extends User{ } //interface 문법 구조가 객체지향이라 더 이해하기 쉬운듯 class 처럼 interface 도 타입으로 사용할 수 있다. interface User{ firstName:string, lastName:string }\t function makeUser(user:User):User{ return { firstName: \"joohee\", lastName:\"kim\" } }\t\t makeUser({ firstName: \"joohee\", lastName:\"kim\" }) 추상클래스는 일반 클래스의 상속을 받기 위해 만들어진 청사진이며 JS로 변환된다. interface는 JS에 존재하지 않는 용어이기 때문에 JS로 변환될 때 User는 노출되지않는다. 따라서 User에 해당하는 파일 사이즈를 줄일 수 있음. //추상클래스를 상속하는 코드 abstract class User{ constructor( protected firstName:string, protected lastName:string ) abstract sayHi(name:string):string abstract fullName():string }\t class Player extends User{ fullName(){ return `${this.firstName} ${this.lastName}` } sayHi(name:string){ return `hello ${name} my name is ${this.firstName}` }\t\t }\t //interface를 상속하는 코드 interface User{ firstName:string, lastName:string, sayHi(name:string):string, fullName():string }\t class Player implements User{ constructor( public firstName:string, public lastName:string ){} fullName(){ return `${this.firstName} ${this.lastName}` } sayHi(name:string){ return `hello ${name} my name is ${this.firstName}` } }\t //interface User를 상속한 코드가 JS로 변환된 코드 class Player{ constructor(firstName, lastName){ this.firstName = firstName, this.lastName = lastName } fullName(){ return `${this.firstName} ${this.lastName}` } sayHi(name:string){ return `hello ${name} my name is ${this.firstName}` } } type alias와 interface의 차이점은 TS 공식문서에도 잘 나와 있다. type alias와 interface의 차이점에 대한 TypeScript 공식 문서 " }, { "title": "[리팩터링] chapter 9 데이터 조직화", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-9/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-30 08:58:00 +0900", "snippet": " p.329데이터 구조 리팩터링. 하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳는다. 그러니 이런 코드를 발견하면 변수 쪼개기를 적용해 용도별로 분리하자. 한편, 파생변수를 질의함수로 바꾸기를 활용하여 변수 자체를 완전히 없애는 게 가장 좋은 해법일 때도 있다. p.330변수 쪼개기 for loop문에 있는 변수 i는 반복문을 한번 돌때마다 값이 바뀐다. 수집 변수는 메서드가 동작하는 중간중간 값을 저장한다. 그 외에도 변수는 긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰인다. 이런 변수에는 값을 단 한번만 대입해야한다. 대입이 두번 이상 이뤄진다면 여러가지 역할을 수행한다는 신호다. 역할이 둘 이상인 변수가 있다면 쪼개야된다. p.338파생 변수를 질의 함수로 바꾸기 가변 데이터는 소프트웨어 p.343참조를 값으로 바꾸기 객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다. 참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체로 만들 수있다. 값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다.일반적으로 불변 데이터 구조는 다루기 더 쉽다. 불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다. 값을 복제해 이곳 저곳에서 사용하더라도 서로 간의 참조를 관리하지 않아도 된다. 그래서 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.한편 값 객체의 이런 특성 떄문에 이번 리팩터링을 적용하면 안 되는 상황도 있다. 예컨대 특정 객체를 열 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 떄 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.기존 코드Person classclass Person{\tconstructor(){\t\tthis._telephoneNumber = new TelephoneNumber();\t}\tget officeAreaCode(){return this._telephoneNumber.areaCode;}\tset officeAreaCode(arg){this._telephoneNumber.areaCode = arg;}\tget officeNumber(){return this._telephoneNumber.number;}\tset officeNumber(arg){this._telephoneNumber.number = arg;}} 추출해서 새로 만들어진 객체(TelephoneNumber)를 갱신하는 메서드 들은 여전히 추출 전 클래스(Person)에 존재할 것이다. 어쨌든 새 클래스가 가리키는 참조가 하나뿐이므로 참조를 값으로 바꾸기에 좋은 상황.TelephoneNumber classclass TelephoneNumber{\t...\tget areaCode(){return this._areaCode;}\tset areaCode(arg){this._areaCode = arg;}\tget number(){return this._number;}\tset number(arg){this._number = arg;}}수정된 코드Person classclass Person{\tconstructor(){\t\tthis._telephoneNumber = new TelephoneNumber();\t}\tget officeAreaCode(){return this._telephoneNumber.areaCode;}\tset officeAreaCode(arg){\t\tthis._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);\t}\tget officeNumber(){return this._telephoneNumber.number;}\tset officeNumber(arg){\t\tthis._telephoneNumber = new TelephoneNumber(this.officeAreaCode,arg);\t}} 먼저 전화번호를 불변으로 만든다. 필드들의 세터들만 제거하면 된다. 세터 제거의 첫 단계로 세터로 설정하던 두 필드를 생성자에서 입력받아 설정하도록 한다.TelephoneNumber classclass TelephoneNumber{\tconstructor(areaCode,number){\t\tthis._areaCode = areaCode;\t\tthis._number = number;\t}\tget areaCode(){return this._areaCode;}\tset areaCode(arg){this._areaCode = arg;}\tget number(){return this._number;}\tset number(arg){this._number = arg;}\tequals(other){\t\tif(!(other instanceof TelephoneNumber)) return false;\t\treturn this.areaCode === other.areaCode &amp;&amp; this.number === other.number;\t}} 대부분의 객체지향 언어는 값 기반 동치성 비교를 할 수 있도록 오버라이드 가능한 동치성 검사 수단을 제공한다. 하지만 JS는 참조기반 동치성을 값 기반 동치성으로 대체하는 일과 관련하여 언어나 핵심 라이브러리 차원에서 지원해주는게 없기 때문에 임의로 equals() 작성" }, { "title": "[리팩터링] chapter 8 기능 옮기기", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-8/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-29 08:58:00 +0900", "snippet": " p.290필드 옮기기함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 한다. 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 한 레코드에 담는게 가장 좋다. 변경 역시 주요한 요인이다. 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야 한다면 필드의 위치가 잘못되었다는 신호다.구조체 여러 개에 정의된 똑같은 필드들을 갱신해야 한다면 한 번만 갱신해도 되는 다른 위치로 옮기라는 신호다.기존 코드Customer classclass Customer{\tconstructor(name, discountRate){\t\tthis._name = name;\t\tthis._discountRate = discountRate;\t\tthis._contract = new CustomerContract(dateToday());\t}\tget discountRate(){return this._discountRate;}\tbecomePreferred(){this._discountRate += 0.03;}\tapplyDiscount(amount){\t\treturn amount.distract(amount.multiply(this._discountRate));\t}\t...}CustomerContract classclass CustomerContract{\tconstructor(startDate){\t\tthis._startDate = startDate;\t}}수정된 코드Customer classclass Customer{\tconstructor(name, discountRate){\t\tthis._name = name;\t\tthis._setDiscountRate(discountRate);\t\tthis._contract = new CustomerContract(dateToday());\t}\tget discountRate(){return this._contract.discountRate;}\t_setDiscountRate(aNumber){this._contract.discountRate = aNumber;}\tbecomePreferred(){this._setDiscountRate(this.discountRate += 0.03);}\tapplyDiscount(amount){\t\treturn amount.distract(amount.multiply(this._discountRate));\t}\t...}CustomerContract classclass CustomerContract{\tconstructor(startDate,discountRate){\t\tthis._startDate = startDate;\t\tthis._discountRate = discountRate;\t}\tget discountRate(){return this._discountRate;}\tset discountRate(arg){this._discountRate = arg;}} p.312문장 슬라이드하기명령-질의 원칙을 지켜가며 코딩을해야 값을 반환하는 함수는 모두 부수효과가 없음을 장담할 수 있다.부수효과가 있는 코드를 슬라이스하거나 부수효과가 있는 코드를 건너뛰어야 한다면 훨씬 신중해야한다.https://martinfowler.com/bliki/CommandQuerySeparation.html p.320반복문을 파이프라인으로 바꾸기컬렉션 파이프라인을 이용하면 처리과정을 일련의 연산으로 표현할 수 있다. 이때 각 연산은 컬렉션을 입력받아 다른 컬렉션을 내뱉는다. 대표적인 연산은 map과 filter다. map은 함수를 사용해 입력 컬렉션의 각 원소를 변환하고, filter는 또 다른 함수를 사용해 입력 컬렉션을 필터링해 부분집합을 만든다. 이 부분집합은 파이프라인의 다음 단계를 위한 컬렉션으로 쓰인다." }, { "title": "[TS] Typescript의 함수", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC-2/", "categories": "Typescript", "tags": "TS, Typescript, JS, Javascript", "date": "2022-06-28 17:29:00 +0900", "snippet": " call signatures 객체 구현시 Type Alias로 코드를 줄였던 것 처럼 call signatures로 함수 의 파라미터와 리턴값에 타입을 설정한다. call signatures를 활용하면 구현 코드와 타입 설정 코드를 분리할 수 있다. type Add = ( a : number , b : number) =&gt; number; const add : Add = (a,b) =&gt; a + b overloading 함수가 여러개의 call signatures를 가지고 있을 때 발생한다. call signature들의 파라미터의 개수가 다를때 여분의 파라미터는 optional이다. type Add = { (a : number, b : number) : number (a : number, b : number, c: number) : number } const add : Add = (a,b,c?:number) =&gt; { if(c) return a + b + c return a + b } //여분의 파라미터 c 의 타입이 number일 것이라고 작성해야함 polymorphism Generic은 모든 타입의 변수를 받는다. call signatures에서는 직접 타입을 입력했지만 Generic을 사용하면 타입을 직접 입력할 필요가 없다. TS가 알아서 할당된 변수에 맞는 call signature를 생성해준다. type SuperPrint ={ &lt;TypePlaceholder&gt;( arr: TypePlaceholder[] ) : void } //모든 변수를 입력하기 위해 모든 타입을 나열할 필요가 없다. //TypePlaceholder라는 Generic을 입력해 모든 타입 조합을 대신한다. //보통 T 를 사용한다. const superPrint : SuperPrint = (arr) =&gt; { arr.forEach( i =&gt; console.log(i) ) } superPrint([1,2,3,4]) superPrint([true, false]) superPrint([1,2,\"hello\",\"bye\"]) superPrint([1,2,true, \"hello\"]) //TS가 배열의 요소들이 어떤 타입인지 알아서 판단한다. any가 Generic을 대신해도 에러는 나지 않지만 각 배열의 요소 타입이 모두 any가 된다. Generic은 요구한대로 signature를 생성해주는 도구와 같다. 파라미터가 여러개인 경우, 파라미터들을 Generic으로 설정하고 싶으면 파라미터의 개수만큼 Generic을 명시하면 된다. type SuperPrint = &lt; T, M &gt;( arr : T[], b : M ) =&gt; T " }, { "title": "[TS] Typescript의 타입", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC/", "categories": "Typescript", "tags": "TS, Typescript, JS, Javascript", "date": "2022-06-28 13:33:00 +0900", "snippet": "TS is JS with syntax for types. TS 는 개발자의 실수를 줄여준다. JS 는 실수를 피하기위해 만들어져 있지 않다. JS는함수를 실행할 때 올바른 argument를 사용하도록 강제하지도 않고 객체안에 존재하지 않는 함수를 불러와도 코드를 실행해야만 에러메세지를 볼 수 있다. TS는 코드에 에러가 있으면 JS로 컴파일되지 않고 에러메시지를 띄운다. 따라서 에러가 있으면 런타임 전에 확인할 수 있다. 변수 타입 선언 TS의 문법에 따라 TypeCheck가 변수의 타입을 확인한다. 변수의 타입을 명시할 수있다. let a = \"hello\" let b : boolean = false let c : number[] = [] 항상 변수의 타입을 명시할 필요는 없다. TS가 알아서 추론한다. 객체 타입 선언 변수명 뒤에 ?를 붙여 변수가 mandatory가 아니라 optional이라는 것을 명시할 수 있다. const player :{ name : string, age?: number } = { name : \"joohee\" } //player 의 age는 number 또는 undefined 타입이다.\t if( player.age &amp;&amp; player.age &lt; 10){ //player.age가 존재하는지 확인하는 코드 작성 //player.age 가 존재하는지 먼저 확인하고 player.age 가 10보다 작다면 if문을 탄다. } 타입 선언이 반복된다면 Alias 타입을 작성해 코드를 줄일 수 있다. type Age = number; type Player = { name : string, age ?: Age } const joohee : Player = { name : \"joohee\" } const song : Player = { name : \"song\", age : 2 } function playerMaker(name:string): Player{ return { name } } const mijung = playerMaker(\"mijung\") mijung.age = 32 //playerMaker의 리턴타입이 Player 라고 명시해야 mijung이 Player 타입이라는 것을 알 수 있다. type Team = \"red\" | \"blue\" | \"white\" type Height = 160 | 170 | 180\t interface Player { name : string, team : Team, height : Height }\t //타입 option에 맞지 않는 데이터는 입력불가 readonly 설정을 할 수 있다. 변수와 객체의 속성에 readonly 속성을 추가해 데이터 변경이 불가능하도록 설정할 수 있다. const numbers : readonly number [] = [1,2,3,4] numbers.push() //'push' does not exist on type 'numbers'라는 에러 메시지가 뜸 서로 다른 타입을 갖고 있는 배열들의 속성을 명시할 수 있다. const player : [number, string, boolean] = [30,\"joohee\",true] any : 모든 타입을 할당 받을 수 있다. TS의 변수의 타입을 제한해 오류를 막는 로직을 건너뛰는 방법이다. JS에서 타입을 명시하지 않고 작성하는 코드 작성방식과 동일한 효과를 얻는다. unknown 작업을 하려면 이 변수의 타입이 뭔지 먼저 확인해야 한다. let a : unknown; if(typeof a === 'number'){ let b = a+1 } void 함수에서 리턴하는 값이 없을 때 함수의 리턴타입은 void다. 굳이 void라고 명시할 필요는 없다. never 함수가 리턴하는 값이 절대 없을 때 function hello():never{ throw new Error(\"아이디가 존재하지 않습니다.\") } 오류를 출력함을 의미 function hello(name : string | boolean){ if(typeof name === \"string\"){\t\t\t }else if(typeof name === \"boolean\"){ }else{ //name의 타입이 string 혹은 boolean이 아닐 때 실행되는 코드 //이때 name의 타입이 never } } " }, { "title": "[리팩터링] chapter 7 캡슐화", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-7/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-27 09:28:00 +0900", "snippet": " p.236레코드 캡슐화하기 p.246컬렉션 캡슐화하기 컬렉션 병수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이 바뀌어버릴 수 있다. 이런 문제를 방지하기 위해 컬렉션을 감싼 클래스에 add(), remove()라는 이름의 컬렉션 변경자 메서드를 만든다. 이렇게 항상 컬렉션을 소유한 클래스를 통해서만 원소를 변경하도록 하면 프로그램을 개선하면서 컬렉션 변경방식도 원하는 대로 수정할 수 있다. 가장 흔히 사용하는 방식은 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다. 복제본을 수정해도 원본 컬렉션에는 영향을 주지 않는다.기존코드Person classclass Person{\tconstructor(name){\t\tthis._name = name;\t\tthis._course = [];\t}\tget name(){return this._name;}\tget courses(){return this._courses;}\tset courses(aList){this._courses = aList;}}Course classclass Course{\tconstructor(name,isAdvanced){\t\tthis._name = name;\t\tthis._isAdvanced = isAdvanced;\t}\tget name(){return this._name;}\tget isAdvanced(){return this._isAdvanced;}}클라이언트\tnumAdvancedCourses = aPerson.courses.filter(c =&gt; c.isAdvanced).length;\tconst basicCourseNames = readBasicCourseNames(filename);\taPerson.courses = basicCourseNames.map(name =&gt; new Course(name,false));\t// 모든 필드가 접근자 메서드로 보호받고 있으니 데이터를 캡슐화했다고 생각할 수 있으나\t//세터를 이용해 수업 컬렉션을 통째로 설정한 클라이언트는 누구든 이 컬렉션을 마음대로 수정할 수 있다.\t\tfor(const name of readBasicCourseNames(filename)){\t\taPerson.courses.push(new Course(name,false));\t}\t//이런 식으로 목록 데이터를 갱신할 수 있다면 Person 객체가 더는 컬렉션을 제어할 수 없으니 캡슐화가 깨진다. \t//필드를 참조하는 과정만 캡슐화하고 필드에 담긴 내용은 캡슐화하지 않았기 때문에 발생하는 문제다.수정된 코드 course 목록을 수정하지 못하도록 course 필드를 캡슐화한다.Person classclass Person{\tconstructor(name){\t\tthis._name = name;\t\tthis._course = [];\t}\tget name(){return this._name;}\tget courses(){return this._courses.slice();}\t// 메서드를 사용하지 않고서는 아무도 목록을 변경할 수 없게 만들기 위해 복제본을 제공한다.\tset courses(aList){this._courses = aList.slice();}\t//set course()를 제거하는 것이 가장 좋지만 set courses()를 제공해야할 필요가 있다면 인수로 받은 컬렉션의 복제본을 필드에 저장하게 한다. \taddCourse(aCourse){\t\tthis._aCourse.push(aCourse);\t}\tremoveCourse(aCourse,fnIfAbsent = () =&gt; {throw new RangeError();}){\t\tconst index = this._courses.indexOf(aCourse);\t\tif(index === -1) fnIfAbsent();\t\telse this._courses.splice(index,1);\t}}Course classclass Course{\tconstructor(name,isAdvanced){\t\tthis._name = name;\t\tthis._isAdvanced = isAdvanced;\t}\tget name(){return this._name;}\tget isAdvanced(){return this._isAdvanced;}}클라이언트\tnumAdvancedCourses = aPerson.courses.filter(c =&gt; c.isAdvanced).length;\t\tfor(const name of readBasicCourseNames(filename)){\t\taPerson.addCourse(new Course(name,false));\t}\t//개별 원소를 추가하고 제거하는 메서드를 제공하기 때문에 setCourses()를 사용할 일이 없어졌으니 제거한다. (set courses() 메서드 제거)\t//set courses()를 제공해야할 필요가 있다면 인수로 받은 컬렉션의 복제본을 필드에 저장한다.\t 기존 데이터는 캡슐화하고 클라이언트가 데이터를 요구할 때 데이터의 복제본을 제공한다면 예상치 못한 데이터 수정이 촉발한 오류에도 기존 데이터는 그대로 남아있다. 컬렉션 관리를 책임지는 클래스라면 항상 복제본을 제공해야 한다. p.251기본형을 객체로 바꾸기 단순 출력 이상의 기능이 필요해지면 그 데이터를 표현하는 전용 클래스를 정의한다. 시작은 기본형 데이터를 단순히 감싼 것과 큰 차이가 없을지 모르나 나중에 특별한 동작이 필요해지면 이 클래스에 추가하면 되니 프로그램이 커질 수록 유용한 도구가 된다.기존 코드Order classclass Order{\tconstructor(data){\t\tthis.priority = data.priority;\t}\t...}클라이언트\thighPriorityCount = orders.filter(o =&gt; \"high\" === o.priority ||\t\t\t\t\t\t\t\t\t\t\"rush\" === o.priority).length;1차 수정된 코드Order classclass Order{\tconstructor(data){\t\tthis.priority = data.priority;\t}\tget priorityString(){return this._priority.toString();}\tset priority(aString){this._priority = new Priority(aString);}\t...} 데이터를 다루기 전에 변수부터 캡슐화한다. 우선순위 속성을 초기화하는 생성자에서 방금 정의한 세터를 활용,이렇게 필드를 자가 캡슐화하면 필드 이름을 바꿔도 클라이언트 코드는 유지할 수 있다. Priority 클래스를 만든다. 이 상황에서는 게터보다 toString()을 사용한다. 클라이언트 입장에서 보면 속성 자체를 받은 것이 아니라 해당 속성을 문자열로 표현한 값을 요청한게 되기 때문이다. 따라서 Order 클래스의 게터가 반환하는 값은 우선순위가 아닌 우선순위를 표현하는 문자열이기 때문에 이름을 priority에서 priorityString으로 바꿔준다. Priority classclass Priority{\tconstructor(value){this._value = value;}\ttoString(){return this._value;}}클라이언트\thighPriorityCount = orders.filter(o =&gt; \"high\" === o.priorityString ||\t\t\t\t\t\t\t\t\t\t\"rush\" === o.priorityString).length; 2차 수정된 코드 접기/펼치기 버튼 2차 수정된 코드 Priority 객체를 제공하는 게터를 Order 클래스에 만든다. Order의 세터가 Priority의 인스턴스를 받도록 한다. Order class class Order{\tconstructor(data){\t\tthis.priority = data.priority;\t}\tget priority(){return this._priority;}\tget priorityString(){return this._priority.toString();}\tset priority(aString){this._priority = new Priority(aString);}\t...} Priority class 우선순위 값을 검증하고 비교하는 로직을 추가한다. class Priority{\tconstructor(value){\t\tif(value instancof Priority) return value;\t\tif(Priority.legalValues().inclues(value))\t\t\tthis._value = value;\t\telse\t\t\tthrow new Error(`&lt;${value}&gt;는 유효하지 않은 우선순위 입니다.`);\t\t}\ttoString(){return this._value;}\tget _index(){return Priority.legalValues().findIndex(s =&gt; s === this._value;)}\tstatic legalValues(){return ['low','normal','high','rush']}\tequals(other){return this._index === other._index;}\thigherThan(other){return this._index &gt; other._index;}\tlowerThan(other){return this._index &lt; other._index;}} 클라이언트 \thighPriorityCount = orders.filter(o =&gt; o.priority.higherThan(new Priority(\"normal\"))).length; p.256임시변수를 질의 함수로 바꾸기 긴 함수의 한 부분을 별도 함수로 추출하고자 할때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다. 추출한 함수에 변수를 따로 전달할 필요가 없어지기 때문이다. 또한 이 덕분에 추출한 함수와 원래 함수의 경계가 더 분명해지기도 하는데, 그러면 부자연스러운 의존관계나 부수효과를 찾고 제거하는 데 도움이 된다. 이번 리팩터링은 클래스 안에서 적용할 때 효과가 크다. 클래스는 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다. 클래스 바깥의 최상위 함수로 추출하면 매개변수가 너무 많아져서 함수를 사용하는 장점이 줄어든다.기존 코드Order classclass Order{\tconstructor(quantity, item){\t\tthis._quantity = quantity;\t\tthis._item = item;\t}\tget price(){\t\tvar basePrice = this._quantity * this._item.price;\t\tvar discountFactor = 0.98;\t\t\t\tif(basePrice &gt; 1000) discountFactor -= 0.03;\t\treturn basePrice * discountFactor;\t}}수정된 코드Order classclass Order{\tconstructor(quantity, item){\t\tthis._quantity = quantity;\t\tthis._item = item;\t}\tget price(){\t\treturn this.basePrice * this.discountFactor;\t\t}\tget basePrice(){ this._quantity * this._item.price;}\tget discountFactor(){\t\tvar discountFactor = 0.98;\t\tif(this.basePrice &gt; 1000) discountFactor -= 0.03;\t\treturn discountFactor;\t}} 임시변수인 basePrice, discountFactor를 메서드로 바꾼다. 두 변수에 const를 붙여 수정을 못하게 변경한다. ( 지나친 재대입으로 컴파일에러가 발생한다. ) basePrice 대입문의 우변을 게터로 추출한다. discountFactor와 관련된 연산을 게터로 추출한다. p.260클래스 추출하기 클래스는 반드시 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다. 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다. 특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다. 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다. 특정 데이터나 메서드 일부를 제거해도 논리적으로 문제가 없다면 분리할 수 있다는 뜻이다.기존의 코드Person classclass Person{\tget name(){return this._name;}\tset name(arg){this._name = arg;}\tget telephoneNumber(){return `(${this.officeAreaCode})${this.officeNumber}`;}\tget officeAreaCode(){return this._officeAreaCode;}\tset officeAreaCode(arg){this._officeAreaCode = arg;}\tget officeNumber(){return this._officeNumber;}\tset officeNumber(arg){this._officeNumber = arg;}}수정된 코드Person classclass Person{\tconstructor(){\t\tthis._telephoneNumber = new TelephoneNumber();\t}\tget name(){return this._name;}\tset name(arg){this._name = arg;}\tget telephoneNumber(){return this._telephoneNumber.toString();}\tget officeAreaCode(){return this._telephoneNumber.areaCode;}\tset officeAreaCode(arg){this._telephoneNumber.areaCode = arg;}\tget officeNumber(){return this._telephoneNumber.number;}\tset officeNumber(arg){this._telephoneNumber.number = arg;}}TelephoneNumber classclass TelephoneNumber{\tget toString(){return `(${this.areaCode})${this.number}`;}\tget areaCode(){return this._areaCode;}\tset areaCode(arg){this._areaCode = arg;}\tget number(){return this._number;}\tset number(arg){this._number = arg;}} 전화번호 정보가 쓸모가 많으니 TelephoneNumber 클래스를 클라이언트에게 공개하려면 ‘office’로 시작하는 메서드를 없애고 TelephoneNumber의 접근자를 바로 사용하도록 바꿀 수 있다. 그러나 기왕 이렇게 쓸거라면 전화번호를 값 객체로 만드는 방법도 있다. (9.4절참조를 값으로 바꾸기 참고) p.264클래스 인라인하기 제 역할을 못해서 그대로 두면 안되는 클래스를 인라인한다. 연락을 옮기는 리팩터링을 하고나니 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생긴다. 이럴 땐 가장 많이 사용하는 클래스로 흡수시키자. 두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인한다. 클레스를 인라인해서 하나로 합친 다음 새로운 클래스를 추출하는 게 쉬울 수도 있기 때문이다.기존 코드Shipment classclass Shipment{\t...\tget trackingInfo(){return this._trackingInformation.display;}\tget trackingInformation(){return this._trackingInformation;}\tset trackingInformation(aTrackingInformation){\t\tthis._trackingInformation = aTrackingInformation;\t}}TrackingInformation classclass TrackingInformation{\tget shippingCompany(){return this._shippingCompany;}\tset shippingCompany(arg){this._shippingCompany = arg;}\tget trackingNumber(){return this._trackingNumber;}\tset trackingNumber(arg){this._trackingNumber = arg;}\tget display(){return `${this.shippingCompany} : ${this.trackingNumber}`;}}클라이언트\taShipment.trackingInformation.shippingCompany = request.vendor;수정된 코드Shipment classclass Shipment{\t...\tget shippingCompany(){return this._shippingCompany;}\tset shippingCompany(arg){this.shippingCompany = arg;}\tget trackingInfo(){return `${this.shippingCompany} : ${this.trackingNumber}`;}\tget trackingInformation(){return this._trackingInformation;}\tset trackingInformation(aTrackingInformation){\t\tthis._trackingInformation = aTrackingInformation;\t}\tget trackingNumber(){return this._trackingNumber;}\tset trackingNumber(arg){this._trackingNumber = arg;}\t}TrackingInformation class클라이언트\taShipment.shippingCompany = request.vendor; p.268위임 숨기기 캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야할 내용을 줄여준다. 캡슐화가 잘 되어 있다면 무언가를 변경해야 할때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기가 훨씬 쉬워진다. 위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야한다. 이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다. 그러면 위임 객체가 수정되더라도 서버 코드만 고치면 되며, 클라이언트는 아무런 영향을 받지 않는다.기존 코드Person classclass Person{\tconstructor(name){this._name = name;}\tget name(){return this._name;}\tget department(){return this._department;}\tset department(arg){this._department = arg;}}Department classclass Department{\t...\tget chargeCode(){return this._chargeCode;}\tset chargeCode(arg){this._charCode = arg;}\tget manager(){return this._manager;}\tset manager(arg){this._manager = arg;}}클라이언트\tmanager = aPerson.department.manager; 클라이언트에서 어떤 사람이 속한 부서의 관리자를 알고 싶어한다. 클라이언트는 부서 클래스가 관리자 정보를 제공한다는 사실을 알아야한다. 이러한 의존성을 줄이려면 클라이언트가 부서 클래스를 볼 수 없게 숨기고, 대신 사람 클래스에 간단한 위임 메서드를 만들면 된다.수정된 코드Person classclass Person{\t...\t//manager 메서드 추가\tget manager(){return this._department.manager;}\t...}클라이언트\tmanager = aPerson.manager; p.271중개자 제거하기 위임 숨기기는 위임 객체를 캡슐화하는 이점을 갖고있으나 위임을 위해 단순 전달만 하는 메서드를 계속 추가해야할 수 있다. 그러면 서버 클래스는 그저 중개자로 전락하여 차라리 클라이언트가 위임 객체를 직접 호출하는 게 나을 수 있다." }, { "title": "[리팩터링] chapter 6 기본적인 리팩터링", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-6/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-24 08:32:00 +0900", "snippet": " p.159코드는 목적과 구현을 분리하여 함수로 구현한다. 코드를 보고 무슨 일을 하는지 파악하는데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 ‘무슨 일’에 걸맞는 이름을 짓는다. 이렇게 해두면 나중에 코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고 본문코드에 대해서는 더이상 신경 쓸 일이 거의 없다.짧은 함수의 이점은 이름을 잘 지어야만 발휘되므로 이름 짓기에 특별히 신경 써야 한다. 절차 함수를 새로 만들고 목적이 잘 드러내는 이름을 붙인다.(‘어떻게’가 아닌 ‘무엇을’ 하는지가 드러나야한다.) 추출한 코드를 원본 함수에서 복사하여 새 함수를 붙여 넣는다. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다. 변수를 다 처리했다면 컴파일한다. 원본 함수에서 추출한 코드 부분을 새로만든 함수를 호출하는 문장으로 바꾼다. 테스트한다. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다. P.169함수 인라인하기. 간접호출을 너무 과하게 쓰는 코드도 흔한 인라인 대상이다. 가령 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임관계가 복잡하게 얽혀있으면 인라인 해버린다. 절차 다형 메서드 인지 확인한다. 인라인할 함수를 호출하는 곳을 모두 찾는다. 각 호출문을 함수 본문으로 교체한다. 하나씩 교체할 때마다 테스트한다. 원래 함수를 삭제한다. p.173변수 추출하기. 표현식이 너무 복잡해서 이해하기 어려울 때는 지역변수를 활용한다. 그러면 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어 코드의 목적을 훨씬 명확하게 드러낼 수 있다. 이 과정에서 추가한 변수는 디버깅에도 도움이 된다. 현재 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋다. 그러나 함수를 벗어난 넓은 문맥에서 까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생각해야 한다. 다시말해 변수가 아닌 함수로 추출해야한다. p.177(변수가 아닌 함수로 추출할때) 객체의 엄청난 장점을 볼 수 있다. 객체는 특정 로직과 데이터를 외부와 공유할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다. … 덩치가 큰 클래스에서 공통 동작을 별도 이름으로 뽑아내서 추상화해두면 그 객체를 다룰 때 쉽게 활용할 수 있어서 매우 유용하다. p.179함수는 프로그램을 작은 부분으로 나누는 주된 수단이다.함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성요소를 조립하는 연결부 역할을 한다. 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다. (매개변수는 함수를 사용하는 문맥을 설정한다. )매개변수를 다르게 정의하면 함수의 활용 범위를 넓힐 수 있다.(심화 학습 필요) p.188변수 캡슐화하기.접근할 수 있는 범위가 넓은 데이터를 옮길 때에는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다. 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것이다. 데이터 캡슐화는 다른 경우에도 도움을 준다. 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나 변경할 때마다 최대한 캡슐화한다. 그래야 자주 사용하는 데이터에 대한 결합도가 높아지는 일을 막을 수 있다.객체 지향에서 객체의 데이터를 항상 private으로 유지해야한다고 강조하는 이유가 있다. p.192값 캡슐화하기. 정확한 기준은 그 데이터가 어디서 오는지, 원본 데이터의 모든 변경을 그대로 반영할 수 있도록 원본으로의 링크를 유지해야 하는지에 따라 다르다. 링크가 필요없다면 데이터를 복제해 저장하여 나중에 원본이 변경되어 발생하는 사고를 방지할 수 있다. 복제본 만들기가 번거로울 때가 많지만, 이런 복제가 성능에 주는 영향은 대체로 미미하다. 반면, 원본을 그대로 사용하면 나중에 디버깅하기 어렵고 시간도 오래 걸릴 위험이 있다. p.197매개변수 객체 만들기데이터 항목 여러 개가 몰려다니면 데이터 구조 하나로 모아준다. 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다. 함수가 이 데이터 구조를 받게 하면 매개변수의 수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.코드에 범위 개념이 필요함을 깨달았다면 최댓값과 최솟값쌍을 사용하는 코드(예시 코드)를 발견할 때마다 범위 객체로 바꾸자. 이러한 값 쌍이 어떻게 사용되는지 살펴보면 다른 유용한 동작도 범위 클래스로 옮겨서 코드베이스 전반에서 값을 활용하는 방식을 간소화할 수 있다. p.202여러 함수를 클래스로 묶기공통데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리는 클래스 하나로 묶는다. 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 함수를 한데 묶는 또 다른 방법으로 여러 함수를 변환함수로 묶기도 있다. 클래스로 묶을 때의 두드러진 장점은 클라리언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체를 일관되게 관리할 수 있다는 점이다. p.208여러 함수를 변환 함수로 묶기변환함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 데이터 필드에 넣어 반환한다. 이렇게 해두면 도출 과정을 검토할 일이 생겼을 때 변환함수만 살펴보면 된다.이 리팩터링 대신 여러함수를 클래스로 묶기로 처리해도 된다. 원본 데이터가 코드 안에서 갱신될때는 클래스로 묶는 것이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다. 여러 함수를 한데 묶는 이유 하나는 도출 로직이 중복되는 것을 피하기 위해서다. 이 로직을 함수로 추출하는 것만으로도 같은 효과를 볼 수 있지만, 데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많다. 변환 함수(또는 클래스)로 묶으면 이런 함수들을 쉽게 찾아 쓸 수 있다." }, { "title": "[리팩터링] chapter 4 테스트 구축하기", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-4/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-23 17:21:00 +0900", "snippet": " p.135테스트를 작성하기 가장 좋은 시점은 프로그래미을 시작하기 전이다. 테스트를 작성하다보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다. 간혹 테스트가 갖춰지지않은 코드를 리팩터링할 때도 있다. 그럴 때는 곧바로 리팩터링하지 않고 먼저 자가테스트 코드부터 작성한다. p.141실패해야할 상황에는 반드시 실패하게 만들자코드에 오류를 주입한다. 자바스크립트 테스트 프레임워크 모카 프레임워크를 사용하는 경우assert, expect문을 사용해서 코드를 검증할 수 있다.실패한 테스트가 하나라도 있으면 리팩터링하면 안된다. p.143완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는게 낫다. p.144테스트 코드에서도 중복은 조심해야하지만 테스트끼리 상호작용하게하는 공유픽스처를 생성하는 원인이 된다. 나중에 다른 테스트에서 이 공유 객체의 값을 수정하면 이 픽스처를 사용하는 또다른 테스트가 실패 할 수 있다. 이렇게되면 테스트 결과가 제멋대로된다.describe('province',function(){\tlet asia = new Province(sampleProvinceData();\t//이렇게 하면 안된다.\t...})describe('province',function(){\tlet asia;\tbeforeEach(function(){\t\tasia = new Province(sampleProvinceData())\t...\t});}) 이렇게 작성하면 개별 테스트를 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있다. p.146beforeEach 블록에서 설정한 표준 픽스처를 취해서, 테스트를 수행하고, 이 픽스처가 일을 기대한 대로 처리했는지를 검증한다. 이 패턴을 설정-실행-검증, 조건-발생-결과, 준비-수행-단언 등으로 부른다. p.148경계를 확인하는 테스트를 작성해보면 프로그램에서 이런 특이 상황을 어떻게 처리하는게 좋을지 생각해 볼 수 있다.문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.이러한 오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면 어서션 추가하기를 적용해 오류가 최대한 빨리 드러나게하다. 어서션도 일종의 테스트로 볼 수 있으니 테스트 코드를 따로 작성할 필요는 없다. p.151기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다. 기존 테스트가 명확한지, 테스트과정을 더 이해하기 쉽게 리팩터링할 수는 없는지, 제대로 검사하는지 등을 확인한다. 버그를 발견하는 즉시 발견한 버그를 명확히 잡아내는 테스트를 작성하는 습관을 들이자." }, { "title": "[Next JS] 강의 정리", "url": "/posts/Next-js-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC/", "categories": "NextJS", "tags": "Next JS, JS, Javascript", "date": "2022-06-23 13:18:00 +0900", "snippet": " 라이브러리와 프레임워크의 차이 라이브러리(React js) 와 프레임워크(Next js) 라이브러리는 개발자가 원하는 대로, 사용하고싶을 때 불러온다. React는 항상 App component를 만들고 개발자는 component들을 원하는 대로 채운다.개발자가 언제 React를 부를지 어떤 구조로 작성할지 결정하는 것이다. 따라서 자유도가 높다. 개발자가 코드를 제 자리에 적기만 한다면 프레임워크가 코드를 불러와서 동작시킨다. Next JS에서는 page 폴더에서 코드를 작성한다. Next JS 의 내부에서 component를 구성하지만 개발자가 직접 접근할 수는 없다(추상화) Next JS 의 url 파일명이 url이된다. component명(함수 명)은 중요하지않다. export default 되기만 하면 됨 about.js import Seo from './components/Seo';export default function About() {//component 명이 About이 아니어도 상관없다. return ( &lt;div&gt; &lt;Seo title=\"About\" /&gt; &lt;h1&gt;About&lt;/h1&gt; &lt;/div&gt; );} http://localhost:3000/about 이 about.js의 경로가 된다. Next JS의 페이지는 정적으로 생성된다. React JS는 동적으로 페이지가 생성되어 자바스크립트가 비활성화되면 noscript가 화면에 노출된다. 기본으로 구현된 HTML DOM 뼈대가 없다는 뜻이다. 인터넷이 느린 환경에서는 브라우저가 UI를 만드는데 걸리는 시간이 길다. 따라서 React js로 만든 앱은 인터넷이 느린 환경에서 화면이 늦게 뜰 수 있다. 이것이 브라우저가 모든걸 하는 client-side rendering이다. Next JS는 정적으로 페이지가 구현된다. 느린 네트워크 환경에서 테스트를 해보면 네트워크가 느려도 HTML DOM구조가 구성되어있는 것을 확인할 수 있다. Next JS hydration React JS를 백엔드에서 동작시켜서 페이지를 미리 만든다. 이게 component들을 render시킨다. render이 끝나면 HTML의 형태로 화면에 표현된다. a 태그 사용 자제 anchor를 사용할 경우 페이지가 새로고침되어 server side rendering의 의미가 없다. server side rendering은 서버에서 페이지를 렌더링하기때문에 브라우저에서 화면을 빠르게 노출시킨다는 장점때문에 사용하는건데 새로고침하면 전체 데이터를 다시 받아와야해서 느려진다. 따라서 a태그가 페이지를 새로고침하지 않도록 Link 태그로 a태그를 감싼다. 링크에 속성을 추가하고싶으면 a태그에 속성을 추가하면 된다. Link 태그에 속성을 추가할 경우 동작하지 않는다. Link 태그는 href =’’ 속성만 동작 가능하다. useRouter() hook의 일종으로 location정보를 얻을 수 있다. const router = useRouter();&lt;Link href=\"/\"&gt;&lt;a style={{ color: router.pathname === '/' ? 'red' : 'blue' }}&gt;Home&lt;/a&gt;&lt;/Link&gt;이런 식으로 사용 가능함 CSS module로 css 적용 가능 적용하려는 js파일명과 동일한 module.css 파일을 만들고 css 작성 후 import한다. className속성에 추가한다. 속성은 자바스크립트 객체 프로퍼티 형식으로 적는다. 장점은 랜더링할때 랜덤한 이름을 css 속성에 추가하기때문에 클래스이름 충돌을 겪지 않아도 된다는 것이다. 다수의 css 클래스 속성을 적용하고 싶다면 속성을 문자열 형식으로 작성한다. 8.Styled JSX module.css 를 대신해서 사용할수 있는 기능 module.css 를 작성할 필요없이 js 페이지에 속성을 추가한다. style 태그에 jsx 속성을 추가하고 원하는 css 를 {``} 내부에 작성한다. 역시 class명이 랜덤으로 변경되어 적용되기 때문에 클래스명이 동일하더라도 서로 다른 js파일이라면 css가 적용되지 않는다.9.global style pages 폴더에 _app.js 라는 이름의 App Component를 작성한다. 모든 페이지에 공통으로 사용될 component를 작성하고 그 component에 해당하는 css를 적용할 수 있다. global css는 일반 js파일에는 import하지 못하고 커스텀 App component가 있는 _app.js에만 import 가능하다. 각 페이지마다 global 속성을 추가하는 방법으로 global style을 추가할 수는 있지만 모든 페이지에 style 속성에 global과 해당하는 css를 ctrl + c ,ctrl + v 하는건 비효율적임10.redirects &amp; rewrites next.config.js에 redirects 속성을 추가해 기존의 경로를 새로운 경로로 이동시키는 방법이다. 화면에 노출되는 주소도 변경되기때문에 유저가 변경된 url을 알 수 있다. next.config.js에 rewrites 속성을 추가한다. redirects와 유사한 방법이지만 url에 데이터가 노출되지않게 숨길 수 있다. console network에서 확인해도 config.js에 입력된 source 주소만 노출되고 API_KEY는 보이지 않는다. 기존의 코드 수정된 코드\t+ .env 파일에 API_KEY 데이터를 저장함" }, { "title": "[리팩터링] chapter 3 코드에서 나는 악취", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-3/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-22 10:21:00 +0900", "snippet": " p.114이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. p.115가장 간단한 코드 중복의 예로, 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있다. 이럴 때는 함수 추출하기를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다. 코드가 비슷하긴한데 완전히 똑같지는 않다면, 먼저 문장 슬라이드하기로 비슷한 부분은 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 사려본다. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 옮긴다. p.115짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문코드를 볼 이유가 사라진다.그러기 위해서는 훨씬 적극적으로 함수를 쪼개야한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수의 이름은 동작 방식이 아닌 의도가 드러나게 짓는다. … p.116함수가 매개변수와 임시 변수를 많이 사용한다면 추출작업에 방해가 된다. 이런 상황에서 함수를 추출하다보면 추출된 함수에도 매개변수가 너무 많아져서 리팩터링 전보다 난해해 질 수 있다. 그렇다면 임시 변수를 질의함수로 바꾸기로 임시변수의 수를, 매개변수 객체 만들기와 객체 통째로 넘기기로는 매개변수의 수를 줄일 수 있을 것이다.( 심화 학습 필요)…여전히 임시변수와 매개변수가 너무 많다면 함수를 명령으로 바꾸기를 고려해보자. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려있는 경우가 많다. 이런 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다. 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 것이 좋다. 조건문이나 반복문도 추출대상의 실마리를 제공한다. 조건문은 조건문 분해하기로 대응한다. 거대한 switch문을 구성하는 case문 마다 함수 추출하기를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 조건부 로직을 다형성으로 바꾸기를 적용한다. 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여있기 때문일 수 있다. 이럴 때는 과감히 반복문 쪼개기를 적용해 작업을 분리한다. p.117다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 매개변수를 질의 함수로 바꾸기로 제거할 수 있다. 사용중인 데이터 구조에서 값을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기를 적용해서 원본 데이터구조를 그대로 전달한다. 항상 함께 전달되는 매개변수들은 매개변수 객체 만들기로 하나로 묶어버린다. 함수의 동작방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애준다. 클래스는 매개변수 목록을 줄이는데 효과적인 수단이기도 하다. 특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다. 이럴 때는 여러 함수를 클래스로 묶기를 이용하여 공통값들을 클래스의 필드로 정의한다. p.117전역데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는 것이 문제다. 그래서 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾기 굉장히 어렵다. 클래스 변수와 싱글톤에서도 같은 문제가 발생한다. 이를 방지하기 위한 대표적 리팩터링 방법은 변수 캡슐화하기다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위로 최소로 줄이는 것도 좋다. p.118데이터를 수정해버리면 프로그램이 오작동하는 경우가 있다. 따라서 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 원래 데이터는 그대로 둔 채 변경하려는 값에 해당하는 복사본을 만들어서 반환한다 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다. 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 변수 쪼개기를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 갱신로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. API를 만들 때는 질의 함수와 변경함수 분리하기를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게한다. 가능한 한 세터 제거하기도 적용한다. 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다. 값을 다른 곳에서 설정 할 수 있는 가변 데이터는 최악이고 쓸데없는 코드이기도 하다. 이럴 때는 파생변수를 질의함수로 바꾼다. 변수의 유효범위가 단 몇줄이면 가변 데이터라 해도 문제를 일으킬 일이 별로 없다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도가 커진다. 따라서 여러 함수를 클래스로 묶기나 여러함수를 변환함수로 묶기를 활용해서 변수를 갱신하는 코드들의 유효범위를 클래스나 변환으로 제한한다. 구조체처럼 내부 필드에 데이터를 담고있는 변수라면 일반적으로 참조를 값으로 바꾸기를 적용하여, 내부필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다. p.119뒤엉킨 변경은 단일책임원칙SRP이 제대로 지켜지지 않았을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때 발생한다. 예컨데 지원해야하 데이터베이스가 추가될 때마다 함수 세개를 바꿔야 하고, 금융 상품이 추가될 때마다 또다른 함수 네개를 바꿔야하는 모듈이 있다면 뒤엉킨 변경이 발생한 것이다. 데이터베이스연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 프로그래밍이 편하다. 데이터베이스에서 데이터를 가져와 금융상품로직에서 처리해야하는 일처럼 순차적으로 실행되는게 자연스러운맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 방식으로 단계를 분리한다. (단계 쪼개기)전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다. (함수 옮기기) 그러면 처리과정이 맥락별로 구분된다. 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 함수 추출하기 부터 수행한다. p.120 산탄총 수술은 코드를 변경할 떄마다 자잘하게 수정해야하는 클래스가 많을때. 이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 한 클래스로 묶기를 적용한다. 데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환함수로 묶기를 적용한다. 이렇게 묶은 함수들의 출력결과를 묶어서 다음 단계의 로직으로 전달 할 수 있다면 단위 쪼개기를 적용한다.어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다. 메서드나 클래스가 비대하지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 리팩터링 할 수 있다. p.121기능편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 발생한다. 이럴때는 이 함수가 데이터와 가까이 있도록 옮겨주면 된다. 때로는 함수의 일부에서만 기능을 편애할 수 있다. 이럴때는 그 부분만 독립함수로 빼낸 다음, 원하는 모듈로 보내준다.함수가 사용하는 모듈이 다양하다면 가장 많은 데이터를 포함한 모듈로 옮긴다. 함수 추출하기로 함수를 여러조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.이를 거스르는 복잡한 패턴도 있다. ‘디자인 패턴’ 중 전략 패턴과 방문자 패턴이 있다. 켄트 백의 자기 위임도 여기에 속한다. ( 심화 공부 필요) p.122데이터 항목들이 여러 곳에서 뭉쳐다니고 클래스 두어개의 필드에서, 혹은 여러 메서드의 시그니처에서 발견될 때. 필드 형태의 데이터 뭉치는 클래스 추출하기로 하나의 객체로 묶는다. 메서드 시그니처의 데이터 뭉치는 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해서 매개변수 수를 줄인다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요 없다. 새 객체로 뽑아낸 필드가 두개 이상이기만 해도 확실히 예전보다 나아진다.데이터 뭉치인지 판별하려면 값 하나를 삭제해본다. 그랬을때 나머지 데이터만으로는 의미가 없다면 객체로 환생시킬 데이터 뭉치이다. 클래스로 만들어보자. 기능편애를 없애는 과정에서 새로운 클래스를 만들었다면 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴본다. 이러한 연계 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어진다. p.123자신에게 주어진 문제에 기본형 (원시타입)을 사용하는 것보다 딱 맞는 기초타입을 직접 정의하는 것이 좋다. 기본형을 객체로 바꾸기를 적용하자. 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면 타입코드를 서브클래스로 바꾸기와 조건부 로직을 다형성으로 바꾸기를 차례로 적용한다. (심화 학습 필요)자주 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 클래스 추출하기와 매개변수 객체 만들기를 이용한다. p.124똑같은 조건부로직(switch/case문이나 길게 나열된 if/else문)이 여러 곳에서 반복해 등장하는 코드의 문제점. 조건절을 하나 추가할 때 마다 다른 switch문도 모두 찾아서 함께 수정해야하기 때문이다. 이럴 때 다형성을 활용한다. (심화 학습 필요) p.124일급함수를 지원하는 언어가 많아졌다. 반복문을 파이프라인으로 바꾸기를 적용해 제거할 수 있다. filter 나 map 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.일급함수일급 함수를 가진 언어에서는 함수를 다른 함수에 인수로 제공하거나, 함수가 함수를 반환할 수 있으며, 변수에도 할당할 수 있습니다. p.125본문코드를 그대로 쓰는 것과 진배없는 함수도 있고, 실질적으로 메서드가 하나뿐인 클래스도 있다. 이런 프로그램 요소는 함수 인라인하기, 클래스 인라인하기로 처리한다. 상속을 사용했다면 계층 합치기를 적용한다. p.125‘나중에 필요할거야’ 라는 생각으로 만든 코드는 치워버리기. 하는 일이 없는 추상클래스는 계층 합치기로 제거한다. 쓸데없이 위임하는 코드는 함수 인라인하기나 클래스 인라인하기로 삭제한다. 본문에 사용되지 않는 매개변수는 함수 선언 바꾸기로 없앤다. 추측성 일반화하는 테스트 케이스부터 삭제하고 죽은 코드 제거하기 p.126특정 상황에만 값이 설정되는 임시 필드는 클래스 추출하기로 수정한다. 그런 다음 함수 옮기기로 인시 필드들과 관련된 코드를 모조리 새 클래스에 몰아 넣는다. 또한, 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데, 특이 케이스 추가하기로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있다. p.126메시지 페인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 가령 getSomething() 같은 게터가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나열되는 코드가 있다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야한다. 이 문제는 위임숨기기로 해결한다. 이 리팩터링은 메시지 체인의 다양한 연결점에 적용할 수 있다. 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다 보면 중간 객체들이 모두 중개자가 돼버리기 쉽다. 그러니 최종 결과 객체가 어떻게 쓰이는지 부터 살펴보는 것이 좋다. 함수 추출하기로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 함수 옮기기로 체인을 숨길 수 있는지 살펴보다. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라어인트 중 그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 된다면, 이 요구를 처리해줄 메서드를 추가한다. (심화 학습 필요) p.127클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 중개자 제거하기를 활용하여 실제로 일하는 객체와 직접 소통하게 한다. 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인한다. p.128여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로 만들거나 위임 숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다. 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있다. 그러면 서브 클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용한다. p.128한 클래스가 너무 많은 일을 하려다보면 필드 수가 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복코드가 생기기 쉽다. 이럴 때는 클래스 추출하기로 필드들 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해보이는 필드들을 선택하면 된다. 일반적으로는 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 클래스를 추출하기보다 슈퍼 클래스 추출하기나 실질적으로 서브 클래스 추출하기에 해당하는 타입코드 서브 클래스로 바꾸기를 적용하는 편이 더 쉬울 것이다. 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복코드와 혼동을 일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다. 클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지 단서를 얻을 수도 있다. 먼저 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다. 이때 각각의 기능 그룹이 개별 클래스로 추출될 후보다. 유용한 기능 그룹을 찾았다면 클래스 추출하기, 슈퍼 클래스 추출하기, 타입코드를 서브클래스로 바꾸기 등을 활용해서 여러 클래스로 분리한다. p.129클래스를 사용할 때 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점이다. 단, 교체하려면 인터페이스가 같아야한다. 따라서 함수 선언 바꾸기로 메서드 시그니처를 일치시킨다. 때로는 이것만으로 부족한데, 이럴 때는 함수 옮기기를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다. 그러다 대안 크래스들 사이에 중복 코드가 생기면 슈퍼클래스 추출하기를 적용할지 고려해 본다. p.130데이터 클래스란 데이터 필드와 게터, 세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장 용도로만 쓰이다보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다. 이런 클래스에 public 필드가 있다보면 레코드 캡슐화하기로 숨긴다. 변경하면 안되는 필드는 세터 제거하기로 접근을 원천 봉쇄한다.메서드를 통째로 옮기기 어렵다면 함수 추출하기를 이용해서 옮길 수 있는 부분만 별도 메서드로 뽑아낸다. 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있다는 신호 일 수 있다. 이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다." }, { "title": "[JS] this 바인딩", "url": "/posts/this-%EB%B0%94%EC%9D%B8%EB%94%A9/", "categories": "JS", "tags": "JS, Javascript, class, this", "date": "2022-06-21 15:35:00 +0900", "snippet": "JS 로 만드는 간단한 게임 어플리케이션을 리팩터링 하다 발생한 이슈 기존 코드(main.js)필드 클릭시 event target이 당근이라면 당근 이미지 삭제 + 점수 증가 + 당근 사운드 플레이 + 점수 판 업데이트하지만 필드 클릭시 event target 이 벌레라면 게임이 종료되는 코드다. 기존엔 main.js파일에 모든 기능이 나열되어 있었기 때문에 문제가 없었다.하지만 기능을 분리하면서 문제가 발생했다.Field 클래스를 main.js에서 분리하고 main.js에 Field 클래스를 import한 후기존의 onFieldClick함수를 field의 이미지를 클릭하는 함수와 이미지를 클릭할때마다 점수가 변하는 함수로 나누었다.Field.classmain.js이때 Field 클래스의 addEventListener 에 매개변수로 있는 this.onClick을 인자로 전달할 때 Field 클래스의 정보가 전달되지않았다.this.onClick이 클래스와 바인딩되지 않았다는 것이다.따라서 Field 클래스의 정보를 전달하기 위해서는 바인딩을 명시적으로 해줘야한다.첫번째 방법this.onClick = this.onClick.bind(this);를 추가해준다. 자주 사용되는 방법은 아님두번째 방법this.field.addEventListener('click', (event) =&gt; this.onClick);자주 사용되는 방법이다.세번째 방법함수를 멤버변수로 만들고 변수가 arrow function을 가리킨다." }, { "title": "[리팩터링] chapter 2 리팩터링 원칙", "url": "/posts/%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%EC%B1%95%ED%84%B0-2/", "categories": "리팩터링", "tags": "리팩터링, refactoring", "date": "2022-06-21 10:21:00 +0900", "snippet": " p.77리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. p.81리팩터링하면 소프트웨어 설계가 좋아진다.같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다. 그래서 중복코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니다. 프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다. p.82리팩터링하면 프로그래밍 속도를 높일 수 있다.내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠 지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드 베이스 중 작은 일부만 이해하면 된다. 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. p.87쓰레기 줍기 리팩터링코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러개로 작성해놨을 수 있다. 이때 약간 절충을 해야한다. 원래 하려던 작업과 관련없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다. …나라면 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자. p.88리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. …버전관리 시스템에서 리팩터링 커밋과 기능추가 커밋을 분리해야한다는 조언을 들은 적 있다. 이 견해에 동의 하지 않는다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 건 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게된 맥락정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다. p.91기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강상태가 생산성에 미치는 영향을 모른다. 이런 상황에서는 리팩터링한다고 말하지 말라 p.91외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야할 시점에 리팩터링해야 효과를 제대로 볼 수 있다. p.93리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. p.94코드 소유권을 작은 단위로 나눠 엄격히 관리하는데 반대한다. … 코드 소유권을 나눠 관리하면 코드 베이스에서 곧바로 수정하면 훨씬 간단할 일을 계속해서 인터페이스를 관리하느라 시달리게되는 결과를 초래한다. 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용가능하다. 어떤 팀은 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델을 권장하기도 한다. 이렇게하면 함수의 클라이언트도 바꿀 수 있다. p.95버전관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가 결과물이 어느정도 쌓이면 마스터 브랜치에 통합해 다른 팀원과 공유…기능별 브랜치들이 독립적으로 개발되는 기간이 길어질 수록 머지가 복잡해진다. …지속적 통합(CI)에 따르면 모든 팀원이 하루에 최소 한번은 마스터와 통합해야 한다. 이렇게하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 크게 낮출 수 있다. p.96자가 테스트 코드는 리팩터링을 할 수 있게 해줄뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다. 이때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다. 테스트 주기가 짧다면 단 몇줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다. p.99데이터베이스 리팩터링 기법의 핵심은 커다란 변경들을 쉽게 좝하고 다룰 수 있는 데이터 마이크레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다. 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. …( 심화 공부 필요 ) p.105성능 최적화를 위한 방법 중 하나. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 성능에 큰 영향을 주는 부분을 찾고 그 부분만 집중해서 최적화한다. 리팩터링 할 때 처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행한다. p.109자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문트리로 해석해서 다뤄야한다. 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다. ( 심화 공부 필요)" }, { "title": "0617 ~ 0624 공부 계획", "url": "/posts/%EC%9D%BC%EC%A3%BC%EC%9D%BC-%EA%B3%84%ED%9A%8D/", "categories": "계획, 일정정리", "tags": "JS, React JS, CSS, HTML, Debugging", "date": "2022-06-17 16:00:00 +0900", "snippet": " 계획을 작성하기 전에 이 포스팅 작성 배경과 근황, 최근에 느낀 점에 대해 간략하게 글을 작성하고자한다.\t 방통대 기말도 끝났고 퇴사하고 남은 자잘한 스트레스도 완벽하게 해소돼서 다시 빡빡한 스케줄로 공부를 해볼까한다.물론 취준도 해야하는데 자소서 쓸 시간에 공부하고 포트폴리오 만들어서 어느정도 완성된 결과물을 보여주고싶다.어제는 당근마켓 공고에 지원한 고등학생의 블로그를 봤다. 학력무관, 성별무관이라고 적혀있지만 고등학교 재학생이 지원할거라고 당근에서도 예상을 못했을 텐데 그 학생은 지원을 했고 합격하지는 못했지만 인턴기회를 얻었다.\t용기있는 자가 기회를 얻는다는 걸 다시 한번 느꼈고 나도 완벽한 준비가 될때까지 기다리지 말고 어디든 두드려봐야겠다는 용기가 생겼다.\t비록 좋지않은 일을 많이 겪었지만 전회사도 경력직을 원한다고는 했지만 당시 신입인 나를 선택했으니 또 뽑힐수 있을지 모르지. 이력서보고 별로면 안 부르겠지 일단 용기내고 마음에 드는 회사에 지원서를 제출하기로 했다.오늘 하루종일 계획하는 데 시간을 보냈고 단기, 장기 계획을 세웠다.입사 지원시 어떤 포트폴리오를 제출해야할지 감은 안 오고 공부는 해야겠고 비싼 부트캠프 들어가기는 싫어서 동영상 강의랑 스터디를 최대한 활용하기로 했다. 이전부터 프론트엔드 개발자는 css, html를 읽을 줄 알아야된다는 말을 귀에 못이 박히게 들어서 css 레이아웃 강의를 빠른 속도로 수강한다. JS 공부는 이전부터 하고있었지만 앞으로 React JS, Next JS, Node JS도 같이 공부할거라서 현대적인 JS를 심층적으로 공부해야한다. 강의 수강을 메인으로하고 부족한 공부는 읽고있었던 ‘자바스크립트 딥다이브’를 참고해서 보충하기로한다. 아직 공부가 부족해서 리팩터링보다 JS 기초 공부를 해야한다고 생각했으나 ‘이대로 가다간 리팩터링은 영원히 뒷순위가 되겠다’ 라는 생각이 들어서 다른 공부와 병행하기로 했다. 리팩터링은 주니어 개발자에게도 어쩌면 제일 도움이 되지않을까 싶어서 일단 공부를 시작하기로 한다. 리팩터링 스터디를 끝내고 얼마나 도움이 되었는지 소감을 적어보겠다. Java도 공부할 생각은 있지만 현재 JS 언어,JS 파생언어, JS 개발 환경에 대한 관심이 크기때문에 후순위로 미루기로한다.노션에만 적어놓으면 또 흐지부지 될 것 같아서 아무도 안보는 블로그지만 이 블로그에라도 올려놓는다.양심이 있으면 일정에 맞춰서 공부하겠지? ㅋㅋㅋ 하루 공부 목표를 달성하면 체크박스에 체크하고 그날 공부한 내용은 포스팅하기 깃 예전 계정에 있던 프로젝트 새 계정으로 옮기기 커밋 메시지 규칙 정리글 매일 읽고 커밋 메시지 작성 드림코딩 : 브라우저 101 0617일까지 완강 0618, 0619 걸쳐서 CSS layout 강의 완강 + 챌린지 신청 리팩토링 리팩토링 24일까지 완독( 미라클 모닝할때 읽기 ) 드림코딩 : 리팩토링 강의 수강신청하고 17일까지 완강 노마드 코더 Next JS 시작하기 0618 완강 노마드 코더 당근마켓 클론코딩 0620 ~ 0624 완강 + 챌린지 신청 19일 주간회고 작성하고 공유하기" }, { "title": "[HTTP] HTTP 상태코드", "url": "/posts/HTTP-%EC%9B%B9-%EC%A7%80%EC%8B%9D-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-3/", "categories": "HTTP, HTTP status, network", "tags": "HTTP, HTTP status, network", "date": "2022-06-16 11:46:00 +0900", "snippet": " HTTP 상태코드 클라이언트가 보낸 요청의 처리상태를 알려주는 응답 형식 1xx (informal) : 요청이 수신되어 처리중 - 거의 사용되지 않음 2xx (successful) : 요청 정상 처리 3xx (redirection) : 요청을 완료하려면 추가 행동 필요 4xx (client error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없다 5xx (server error) : 서버 오류, 서버가 정상 요청을 처리하지 못함 2xx (successful) 200 OK- 성공 201 Created - 요청성공해서 새로운 리소스 생성됨, 응답의 Location 헤더 필드에 URI가 첨부됨 202 Accepted - 요청은 접수됐으나 아직 처리 완료안됨, 잘 사용하지 않음 204 No Content - 요청은 수행했지만 응답 페이로드에 보낼 데이터가 없다. 데이터를 전송하고도 같은 화면을 유지할때 사용함 ( 웹 문서 편집기의 save 버튼 의 결과 성공/실패 이외의 내용은 중요하지 않음) 성공해도 200, 201까지만 사용하는 경우가 많다. 3xx (redirection) 요청을 완료하기 위해 유저 에이전트의 추가조치가 필요하다 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 Location위치로 리다이렉트 리다이렉트 : 영구 리다이렉션(301,308), 일시 리다이렉션 : PRG(Post Redirect Get), 특수 리다이렉션(응답 대신 캐시 사용) 영구 리다이렉션 : 301, 308 원래의 URL 사용하지 않음, 검색 엔진에서도 변경 인지 301 Moved permanently : 리다이렉트시 요청 메소드가 GET으로 변하고 본문이 제거될 수 있다. 308 Permanent Redirect : 301과 기능 동일, 리다이렉트시 요청 메소드, 본문 유지 - 거의 사용하지 않음 일시적 리다이렉션 : 302, 303, 307 리소스의 URI가 일시적으로 변경 302 Found **: 리다이렉트 요청 메소드가 GET으로 변하고, 본문이 제거될 수 있다. - 대부분 변한다.(MAY) 303 See Other **: 302와 기능이 같다, 리다이렉트 요청 메소드가 GET으로 변경된다. (MUST) 307 Temporary Redirect **: 302와 기능이 같다, 리다이렉트 요청 메소드와 본문 유지 PRG(Post Redirect Get) : POST로 제품 주문 후에 주문 결과 화면을 GET 메소드로 리다이렉트, 새로고침해도 결과 화면은 GET 조회. 중복 주문 대신에 결과 화면만 GET으로 다시 요청 - 새로고침해도 GET으로 결과 화면만 조회. 서버에 오류가 줄어서 좋음 기타 리다이렉션 300 multiple choice : 사용 잘 안함 304 Not Modified : 캐시를 목적으로 사용, 클라이언트에게 리소스가 수정되지 않음을 알려주고 클라이언트는 로컬에 저장된 캐시를 재사용한다. 응답에 메시지 바디가 없다. 조건부 GET HEAD 요청시 사용 4xx (Client Error) 오류의 원인이 클라이언트에 있다. 같은 요청을 다시 보내도 요청이 실패할 가능성이 높다. 400 Bad Request : 요청 구문, 메시지 등의 오류. 요청을 재검토하고 보내야한다. 401 Unauthorized : 인증이 되지않음. 인증과 인가 구분이 안되어있다. 인증 Authentication : 로그인 여부 인가 Authorization : 권한 부여 여부 403 Forbidden : 서버가 요청을 이해했으나 승인을 거부함. 접근 권한이 없는 리소스에 접근했을 때 발생하는 오류 404 Not Found : 요청한 리소스가 서버에 없음, 접근 권한이 없는 리소스에 접근할 때 리소스 존재 여부를 밝히고 싶지 않으면 보내는 response 5xx (Server Error) 서버 복구 후 같은 요청을 다시보내면 요청이 성공할 가능성이 있다. 500 Internal Server Error : 서버 내부의 문제로 오류 발생 503 Service Unavailable : 서버의 일시적 과부하, 예정된 작업으로 잠시 요청을 처리할 수 없음을 표현 Retry - after 헤더 필드로 얼마 뒤에 복구되는지 보낼 수 도 있다. 503보다는 보통 500 사용 웬만해서는 5xx에러 발생시키면 안된다. null pointer exception, db 오류가 아닌 이상 다른 오류로 설정해야 수정하기 용이함 HTTP 헤더 HTTP 전송에 필요한 모든 부가정보 https://developer.mozilla.org/ko/docs/Web/HTTP/Headers 필요시 임의의 헤더 필드 추가 가능 캐시와 조건부 요청 캐시 기본 동작 캐시가 없을 때 : HTTP 헤더와 HTTP 바디를 받아옴, 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 받아야한다, 브라우저 로딩 속도가 느리다. 캐시 적용시 : 네트워크를 사용하지 않아도 된다, 브라우저 로딩 속도가 빠르다 cache-control 의 max-age 정보를 받아 응답 결과를 캐시에 저장한다. 두번째 요청시 캐시의 유효시간을 검증하고 캐시에서 데이터를 가져온다. 캐시 시간 초과 : 캐시 유효 시간이 초과된 것을 확인 데이터 재요청 , 기존의 캐시 삭제후 새 데이터 캐시에 저장 검증 헤더와 조건부 요청 Last-modified 캐시 유효 시간은 초과되었지만 데이터가 변경되지 않은 경우 → 데이터를 새로 전송받는 대신에 저장해두었던 캐시를 재사용할 수 있다. Last-modified 속성 확인 : 데이터가 마지막에 수정된 시간을 확인해서 기존 캐시와 비교 클라이언트에서 if-Modified-Since 속성에 기존 캐시의 데이터 최종 수정일을 넣어 전송 서버에서 if-Modified-Since 데이터를 검증후 데이터 미변경시 HTTP body가 없는 304 Not Modified 전송 (데이터 변경시 200 OK 와 데이터 재전송) 클라언트는 캐시에 저장되어있는 데이터 재활용 console → network → status 304 &amp; request header의 if-modified-since로 확인 가능 검증헤더와 조건부 요청 - ETag 서버에서 별도의 캐시 로직을 관리하고 싶은 경우, 데이터 수정일자는 변경되었지만 데이터는 변경되지 않은 경우 캐시용 데이터에 임의의 고유 버전 명을 넣는다. 데이터가 변경되면 이름을 변경한다. → ETag가 같으면 유지, 다르면 다시 받기 서버에서 ETag 값을 포함한 데이터를 전송 cache-control 시간을 초과했으면 클라이언트에서 if-None-Match : ETag명 입력후 전송 서버에서 ETag명 확인후 일치하면 304 Not Modified 응답보냄 클라언트는 캐시에 저장되어있는 데이터 재활용 어플리케이션 배포 주기에 맞추어 ETag를 모두 갱신하기도 함 캐시 제어 헤더 Cache-Control : max-age, no-cache(데이터는 캐시해도 되지만 항상 원 서버에 검증하고 사용), no-store(데이터에 민감한 정보가 있으므로 저장 불가) Pragma : no-cahe(no-cahe와 동일하게 동작) HTTP 1.0 하위호환으로 현재 자주 사용하지 않음 Expires : 캐시 만료일을 정확한 날짜로 지정, Cache-Control : max-age 권장 프록시 캐시 웹 브라우저가 직접 멀리있는 원 서버에 접근하는게 아니라 원 서버의 캐시정보를 갖고있는 근처의 프록시 캐시 서버(public cache)에 접근, 웹 브라우저에 private cache를 저장한다. Cache-Control 속성 public : 응답이 public cache에 저장되어도 된다. private (디폴트) : 응답이 개인의 웹 브라우저에만 저장되어야한다. private cache에 저장해야함. s-maxage : 프록시 서버에만 적용된다. 캐시 무효화 웹 브라우저에서 임의로 캐시를 하는 경우가 있기 때문에 캐시를 무효화하고싶다면 필수적으로 값을 설정해 응답해야한다. Cache-Control : no-cache, no-store, must-revalidate(캐시 만료 후 최초 조회시 원 서버에 검증해야함, 원 서버 접근 실패시 반드시 504 오류발생 ) Pragma: no-cache " }, { "title": "[HTTP] HTTP 메서드", "url": "/posts/HTTP-%EC%9B%B9-%EC%A7%80%EC%8B%9D-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-2/", "categories": "HTTP, HTTP status, network", "tags": "HTTP, HTTP status, network", "date": "2022-06-14 10:46:00 +0900", "snippet": " HTTP 메서드 URI 설계에서 가장 중요한 것은 리소스 식별이다. 리소스와 행위를 분리 → 리소스 : 목적어, 행위 : 동사 GET : 리소스 조회 POST : 요청 데이터 처리, 주로 등록에 사용 PUT : 리소스를 대체, 해당 리소스가 없으면 생성 PATCH : 리소스 일부 변경 DELETE : 리소스 삭제 HEAD : GET과 동일하지만 메세지바디 제외 헤더만 요청 OPTIONS, CONNECT, TRACE … 생각보다 다양하다 GET 서버에 전달하고 싶은 데이터는 쿼리를 통해 전달 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 실무에서는 메시지 바디 사용하지 않음(지원하지 않는 서버가 많다) 조회할 때는 GET 사용하는게 유리, 캐싱이 가능하다. POST는 캐싱이 어려움 POST 주로 신규 데이터 등록, 변경된 프로세스 수정에 사용 신규 생성시 응답 데이터 (201 CREATED, Location : path, 등록된 데이터) 사용 예시 : 회원가입, 게시판 글쓰기, 댓글 달기, 신규 주문 생성, 기존 데이터 수정 프로세스를 처리하는 경우에 사용 - 다음 데이터 프로세스를 처리하는 단계에서 사용한다. POST의 결과로 새로운 리소스가 생성되지 않는 경우도 있다. 컨트롤 URI(동사형 URI)를 사용하기도 한다. 다른 메서드로 처리하기 애매한 경우 (GET 메서드에 메시지 바디를 넣고싶은데 서버에서 지원하지 않을 때) 애매하면 POST PUT 생성 혹은 존재한다면 기존 파일 덮어쓰기 클라이언트가 리소스를 지정(식별)한다. - POST와의 차이 데이터 필드가 작성되지않으면 그 데이터 모두 사라짐 → 완전 대체 PATCH 리소스 부분 변경 데이터 필드 작성 안 해도 기존의 데이터 필드가 존재하면 유지 지원 안되는 서버일 경우 POST HTTP 메서드 속성 안전 : 호출시 변경발생 안함 멱등(Idempotent) : 한번 호출하든 n번 호출하든 결과가 같다. (Y) GET,PUT,DELETE /(N) POST 멱등 활용하는 이유 : 서버가 오류났을 때, 클라이언트가 같은 요청을 다시 해도 결과가 같길 원할 때 외부요인으로 리소스가 변경될 때 다른 결과값이 나오는 것은 멱등의 판단 기준에 들어가지 않는다. 캐시가능 Cacheable : 실제는 GET(url만 잡으면 됨), HEAD만 캐시 사용 POST, PATCH는 본문 내용까지 캐시키로 고려해야해서 구현 어려움 HTTP 메서드 활용 클라이언트에서 서버로 데이터 전송 쿼리 파라미터 → GET, 주로 정렬필터(검색어) 메시지 바디→ POST, PUT, PATCH 회원가입, 상품주문, 리소스 등록, 리소스 변경 상황 정적데이터 조회- 추가데이터 전달 없음(쿼리 파라미터 없음). URL 경로만 전송, 이미지, 정적 텍스트 문서 동적 데이터 조회- 데이터 전달함, 쿼리 파라미터에 따라 결과가 동적으로 생성된다. 검색, 게시판 목록 조회 GET HTML Form을 통한 데이터 전송 POST : Form 태그내부의 input box에 데이터를 입력하면 입력한대로 데이터가 전송됨.(Content-Type : application/x-www-from-urlencoded) POST GET : Form 태그 내부의 데이터를 쿼리 파라미터로 보냄 enctype = ”multipart/form-data” Content-Type=multipart/form-data;boundary=—XXX, boundary가 각 데이터를 구분함, 주로 파일 업로드에 사용 HTTP API를 통한 데이터 전송 서버에서 서버로 통신할때 사용, 아이폰, 안드로이드에서 전송할때 주로 사용 Form대신에 자바스크립트를 통한 통신에 사용한다. POST, PUT, PATCH : 메시지 바디로 데이터 전송 GET : 쿼리 파라미터로 데이터 전송 Content-Type : application/json 을 주로 사용 (사실상 표준) HTTP API 설계 예시 " }, { "title": "[HTTP] HTTP 기초 지식", "url": "/posts/HTTP-%EC%9B%B9-%EC%A7%80%EC%8B%9D-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-1/", "categories": "HTTP, HTTP status, network", "tags": "HTTP, HTTP status, network", "date": "2022-06-13 18:28:00 +0900", "snippet": "방통대 기말고사가 끝났으니 미뤄둔 공부 목록을 해치워야겠다.이번 학기에 정보통신망을 공부하면서 네트워크 공부를 같이했는데 http 통신 관련된 부분도 나와서 겸사겸사 복습겸 정리한다.생각난 김에 정리하고 올려야 안 까먹을듯. 인프런의 김영한 강사님의 ‘모든 개발자를 위한 HTTP 웹 기초 지식’ 을 참고했으며 부족한 부분은 계속 채워나갈 예정이다. IP 프로토콜의 한계 비연결성 : 패킷을 받을 서버가 없거나 서비스 불능상태라도 패킷 전송 비신뢰성 : 패킷이 순서대로 전송되지않을 수있다. 전송 중 패킷이 소실될 수있다. 패킷 = package + bucket (전송할 데이터 덩어리) TCP 연결지향 - 일단 연결시키고 메세지를 보냄 데이터 전달 보증 - 데이터가 제대로전송이 되었는지 확인가능 순서보장 - 전송하는 패킷들의 순서를 보장해줌 최근엔 최적화가 되어서 3way handshake의 마지막 단계에서 데이터 함께 전송함 단, 3way handshake 는 논리적으로 연결된 것이다. 연결이 확인되었다고해서 중간의 수많은 서버들 사이의 연결이 보장된 것은 아님 UDP IP와 거의 같다 . IP + PORT + 체크섬(메세지가 맞는지 검증) TCP는 3way handshaking, 큰 데이터 등으로 전송 속도가 느리다. 따라서 전송속도를 줄이기 위해 application level로 UDP를 사용해서 전송 최적화를 하는 추세다. PORT 한번에 여러 서버에 통신을 요청할때 사용 패킷에는 출발지 IP, PORT 도착지 IP, PORT , 전송데이터 + α 가 있다. IP가 아파트면 PORT는 동호수. 한 아파트(PC) 안에서 사람들(어플리케이션)가 사는 집을 구분해준다. DNS DNS서버에서 도메인명에 IP주소를 부여해 영문으로 주소를 써도 서버로 연결가능 URI Uniform Resource Identifier 리소스를 식별하는 표준화된 방법 URI 안에 URL, URN이 있음 URL(Resource Locator) : 리소스가 있는 위치를 지정 URN(Resource Name) : 리소스에 이름 부여 URN의 이름만으로 리소스를 찾을 수 있는 방법은 보편화되어있지 않다. 보통 URI와 URL을 동일한 의미로 말함 URL 프로토콜은 어떤 방식으로 자원에 접근할지 정하는 약속 규칙 userinfo, host, port, path, query (query parameter, query string), fragment등이 들어간다. 웹 브라우저 요청 흐름 URL 생성 웹 브라우저가 HTTP 메시지 생성 SOCKET 라이브러리를 통해 웹브라우저에서 TCP/IP 계층으로 메시지 전달 TCP/IP 패킷 생성( 출발지 IP,PORT + 목적지 IP, PORT + HTTP 메시지 ) 웹 브라우저에서 서버로 요청 패킷 전송 서버에서 HTTP 응답 메시지 전송 웹 브라우저 HTML 렌더링 HTTP 모든 것이 HTTP (Hyper Text Transfer Protocol) HTML, 이미지, 영상, 파일 모든 형태의 데이터 전송 가능 TCP 직접 연결은 매우 드문 경우 1.1버전 현재 많이 사용하고 가장 중요하다. (RFC 7230~7235 버전) 2, 3 버전은 성능개선에 초점이 맞춰져있음 HTTP /1.1, HTTP/2 → TCP 기반 HTTP/3 → UDP 기반 HTTP 버전확인 → 개발자 도구 → 네트워크 →마우스 오른쪽 → protocol (h2→ HTTP/2, h3→ HTTP/3) 클라이언트 - 서버 구조 : 클라이언트는 서버에 요청을 보내고 서버는 요청에 대한 결과를 클라이언트에게 보낸다. → 양쪽이 독립적으로 발전할수 있다 (중요) 무상태 프로토콜(stateless) : 서버가 클라이언트의 상태를 보존하지 않는다. stateful : 상태유지, 문맥 보존, 응답서버를 쉽게 바꿀 수 없음 같은 서버가 항상 유지되어야한다. 통신중 서버에 에러가나면 통신을 처음부터 다시해야함 stateless : 상태를 유지하지 않음, 응답 서버를 쉽게 바꿀 수 있음, 클라이언트 요청이 증가해도 서버를 대거 투입가능(수평확장 scale-out) 한계: 상태유지가 필요한 경우가 있다. (ex 로그인 상태유지 → 브라우저 쿠키 + 서버 세션 ), 데이터를 너무 많이보낸다. 최대한 stateless로 설계하고 예외의 경우 stateful로 설계 비연결성 (connectionless) : 요청, 응답 후 연결을 끊음 → 최소한의 자원만을 사용할 수 있다, 여러 클라이언트의 요청을 받을 수 있다. 단점 : TCP/IP 연결을 새로 맺어야한다. - 연결 시간 소모 HTTP 메시지를 통해 통신 HTTP 요청 메세지 : 시작라인(HTTP method, path,HTTP 버전), 헤더(host), 공백라인,(메시지 바디) HTTP 응답 메세지 : 시작 라인(HTTP 버전, HTTP status), 헤더(content-type…), 공백라인(CRLF), 메세지 바디(html) 시작라인(start-line) : request-line, status-line 요청메시지request-line : method SP(SPACE) request-target SP(path) HTTP_version CRLF(엔터) HTTP method : GET(서버에 리소스 요청), POST(서버에 데이터 전송후 처리요청), PUT, DELETE 절대경로[?쿼리] : “/”로 시작하는 경로 HTTP-version 응답메세지 status-line : HTTP 상태코드 : 200 성공 400 클라이언트 요청 오류 500 서버 내부 오류 헤더 HTTP 전송에 필요한 모든 부가정보 메시지 바디의 내용, 크기, 압축여부, 브라우저 정보, 인증정보, 캐시관리 정보 등… 메시지 바디 제외 필요한 모든 메타정보가 다 들어있다. 임의의 헤더 추가시 약속된 클라이언트, 서버만 파악 가능 메시지 바디 실제 전송할 데이터가 들어있음 json, html, 이미지 등 " }, { "title": "깃블로그 chirpy jekyll theme 오류해결하기", "url": "/posts/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-chirpy-theme-%EC%98%A4%EB%A5%98%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/", "categories": "posting, welcome", "tags": "chirpy theme, 오류해결", "date": "2022-05-18 11:37:00 +0900", "snippet": "며칠 jekyll theme을 구경하던 중 찾은 chirpy theme 깔끔하고 원하는 기능이 다 들어있어서 사용하려는데몇번을 다시 깔아도 오류가 발생했다. 튜토리얼대로 작성을해도 커밋 후 올리면이렇게 jekyll theme 적용이 안된 index.html 파일만 그대로 보여줬다.오랜 삽질끝에 찾은 해결방법은 역시 소스의 github issue 창이다.나와 동일한 문제를 겪은 사용자가 2월 10일에 글을 작성했고리눅스 플랫폼 설정을 추가해보라는 글이 있다.bundle lock --add-platform x86_64-linux이전에도 해본 방법이지만 혹시 몰라 다시 시도하고 포스팅을 하나 추가했지만 여전히 blank page깃허브 action을 확인해보니 커밋한 사항이 반영이 안되어 있다. 또한 자동으로 생성된다는 gh-pages 브랜치가 생성이 안됐으며 run fail이 떴다.이 문제 역시 해결방법이 있었다.Settings&gt; Actions &gt; General 에 가서 permission scope를 변경한다.fail이 발생한 커밋 상세페이지에 들어가 rerun을 클릭하니 제대로 돌아갔고!!제대로 동작하는 깃 블로그를 확인할 수 있었다.오늘의 삽질로 얻은 교훈 : 바로 구글링하지말고 공식문서에 달린 이슈와 답글을 먼저 확인하자" }, { "title": "welcome", "url": "/posts/welcome/", "categories": "posting, welcome", "tags": "test", "date": "2022-05-17 18:30:00 +0900", "snippet": "hello" } ]
